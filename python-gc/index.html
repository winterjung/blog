<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style id="typography.js">html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{font:100%/1.45 'georgia',serif;box-sizing:border-box;overflow-y:scroll;}*{box-sizing:inherit;}*:before{box-sizing:inherit;}*:after{box-sizing:inherit;}body{color:hsla(0,0%,0%,0.8);font-family:'georgia',serif;font-weight:normal;word-wrap:break-word;font-kerning:normal;-moz-font-feature-settings:"kern", "liga", "clig", "calt";-ms-font-feature-settings:"kern", "liga", "clig", "calt";-webkit-font-feature-settings:"kern", "liga", "clig", "calt";font-feature-settings:"kern", "liga", "clig", "calt";}img{max-width:100%;margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}h1{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;color:inherit;font-family:-apple-system,'BlinkMacSystemFont','Segoe UI','Roboto','Oxygen','Ubuntu','Cantarell','Fira Sans','Droid Sans','Helvetica Neue',sans-serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:2rem;line-height:1.1;}h2{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;color:inherit;font-family:-apple-system,'BlinkMacSystemFont','Segoe UI','Roboto','Oxygen','Ubuntu','Cantarell','Fira Sans','Droid Sans','Helvetica Neue',sans-serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:1.51572rem;line-height:1.1;}h3{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;color:inherit;font-family:-apple-system,'BlinkMacSystemFont','Segoe UI','Roboto','Oxygen','Ubuntu','Cantarell','Fira Sans','Droid Sans','Helvetica Neue',sans-serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:1.31951rem;line-height:1.1;}h4{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;color:inherit;font-family:-apple-system,'BlinkMacSystemFont','Segoe UI','Roboto','Oxygen','Ubuntu','Cantarell','Fira Sans','Droid Sans','Helvetica Neue',sans-serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:1rem;line-height:1.1;}h5{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;color:inherit;font-family:-apple-system,'BlinkMacSystemFont','Segoe UI','Roboto','Oxygen','Ubuntu','Cantarell','Fira Sans','Droid Sans','Helvetica Neue',sans-serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:0.87055rem;line-height:1.1;}h6{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;color:inherit;font-family:-apple-system,'BlinkMacSystemFont','Segoe UI','Roboto','Oxygen','Ubuntu','Cantarell','Fira Sans','Droid Sans','Helvetica Neue',sans-serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:0.81225rem;line-height:1.1;}hgroup{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}ul{margin-left:1.45rem;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;list-style-position:outside;list-style-image:none;}ol{margin-left:1.45rem;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;list-style-position:outside;list-style-image:none;}dl{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}dd{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}p{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}figure{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}pre{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;font-size:0.85rem;line-height:1.45rem;}table{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;font-size:1rem;line-height:1.45rem;border-collapse:collapse;width:100%;}fieldset{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}blockquote{margin-left:1.45rem;margin-right:1.45rem;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}form{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}noscript{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}iframe{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}hr{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:calc(1.45rem - 1px);background:hsla(0,0%,0%,0.2);border:none;height:1px;}address{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}b{font-weight:bold;}strong{font-weight:bold;}dt{font-weight:bold;}th{font-weight:bold;}li{margin-bottom:calc(1.45rem / 2);}ol li{padding-left:0;}ul li{padding-left:0;}li > ol{margin-left:1.45rem;margin-bottom:calc(1.45rem / 2);margin-top:calc(1.45rem / 2);}li > ul{margin-left:1.45rem;margin-bottom:calc(1.45rem / 2);margin-top:calc(1.45rem / 2);}blockquote *:last-child{margin-bottom:0;}li *:last-child{margin-bottom:0;}p *:last-child{margin-bottom:0;}li > p{margin-bottom:calc(1.45rem / 2);}code{font-size:0.85rem;line-height:1.45rem;}kbd{font-size:0.85rem;line-height:1.45rem;}samp{font-size:0.85rem;line-height:1.45rem;}abbr{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;}acronym{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;}abbr[title]{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;text-decoration:none;}thead{text-align:left;}td,th{text-align:left;border-bottom:1px solid hsla(0,0%,0%,0.12);font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";padding-left:0.96667rem;padding-right:0.96667rem;padding-top:0.725rem;padding-bottom:calc(0.725rem - 1px);}th:first-child,td:first-child{padding-left:0;}th:last-child,td:last-child{padding-right:0;}</style><meta name="generator" content="Gatsby 5.13.3"/><meta data-react-helmet="true" name="description" content="보통 파이썬은 레퍼런스 카운팅 방식으로 가비지 컬렉션을 수행해 메모리를 관리하고, 레퍼런스 카운팅을 사용했을 때 발생할 수 있는 순환 참조 상황을 별도의 가비지 컬렉터로 해결한다고 알고 있다. 이 글에서는 그 가비지 컬렉터가 어떤 방식으로 작동하는지…"/><meta data-react-helmet="true" name="image" content="https://www.winterjung.dev/header.png"/><meta data-react-helmet="true" property="og:title" content="Python GC가 작동하는 원리"/><meta data-react-helmet="true" property="og:url" content="https://www.winterjung.dev/python-gc/"/><meta data-react-helmet="true" property="og:description" content="보통 파이썬은 레퍼런스 카운팅 방식으로 가비지 컬렉션을 수행해 메모리를 관리하고, 레퍼런스 카운팅을 사용했을 때 발생할 수 있는 순환 참조 상황을 별도의 가비지 컬렉터로 해결한다고 알고 있다. 이 글에서는 그 가비지 컬렉터가 어떤 방식으로 작동하는지…"/><meta data-react-helmet="true" property="og:image" content="https://www.winterjung.dev/header.png"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"/><meta data-react-helmet="true" name="twitter:title" content="Python GC가 작동하는 원리"/><meta data-react-helmet="true" name="twitter:description" content="보통 파이썬은 레퍼런스 카운팅 방식으로 가비지 컬렉션을 수행해 메모리를 관리하고, 레퍼런스 카운팅을 사용했을 때 발생할 수 있는 순환 참조 상황을 별도의 가비지 컬렉터로 해결한다고 알고 있다. 이 글에서는 그 가비지 컬렉터가 어떤 방식으로 작동하는지…"/><meta data-react-helmet="true" name="twitter:image" content="https://www.winterjung.dev/header.png"/><meta data-react-helmet="true" name="twitter:creator" content="@res_tin"/><style data-href="/styles.763531abacb6bc2bb1d5.css" data-identity="gatsby-global-css">code,pre{font-family:Fira Code,SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace}pre{background-color:#f6f8fa;line-height:1.45;overflow:auto;padding:16px}code,pre{border-radius:3px}code{background-color:rgba(27,31,35,.05);font-size:.85em;margin:0;padding:.2em .4em}pre>code{background:transparent;border:0;font-size:100%;margin:0;padding:0;white-space:pre;word-break:normal}</style><title data-react-helmet="true">Python GC가 작동하는 원리</title><link data-react-helmet="true" rel="canonical" href="https://www.winterjung.dev/python-gc/"/><link rel="preconnect" href="https://www.googletagmanager.com"/><link rel="dns-prefetch" href="https://www.googletagmanager.com"/><link rel="sitemap" type="application/xml" href="/sitemap-index.xml"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><style data-emotion="css 1uuzzhj">.css-1uuzzhj{margin:0 auto;max-width:700px;padding:2.9rem;padding-top:2.175rem;}</style><div class="css-1uuzzhj"><a href="/"><style data-emotion="css jfvr3k">.css-jfvr3k{margin-bottom:1.45rem;display:inline-block;font-style:normal;}</style><h2 class="css-jfvr3k">winterjung blog</h2><hr/></a><div><h1>Python GC가 작동하는 원리</h1><style data-emotion="css 255c6r">.css-255c6r{word-break:keep-all;}</style><div class="css-255c6r"><p>보통 파이썬은 레퍼런스 카운팅 방식으로 가비지 컬렉션을 수행해 메모리를 관리하고, 레퍼런스 카운팅을 사용했을 때 발생할 수 있는 순환 참조 상황을 별도의 가비지 컬렉터로 해결한다고 알고 있다. 이 글에서는 그 가비지 컬렉터가 어떤 방식으로 작동하는지를 깊게 알아보고자 한다.</p>
<blockquote>
<p>이 글은 CPython을 기준으로 작성되었다.</p>
</blockquote>
<h2>0. GC는 어떨 때 사용하는가</h2>
<p>파이썬에선 기본적으로 <a href="https://docs.python.org/3/glossary.html#term-garbage-collection">garbage collection</a>(가비지 컬렉션)과 <a href="https://docs.python.org/3/glossary.html#term-reference-count">reference counting</a>(레퍼런스 카운팅)을 통해 할당된 메모리를 관리한다. 기본적으로 참조 횟수가 0이 된 객체를 메모리에서 해제하는 레퍼런스 카운팅 방식을 사용하지만, 참조 횟수가 0은 아니지만 도달할 수 없지만, 상태인 reference cycles(순환 참조)가 발생했을 때는 가비지 컬렉션으로 그 상황을 해결한다.</p>
<blockquote>
<p>엄밀히 말하면 레퍼런스 카운팅 방식을 통해 객체를 메모리에서 해제하는 행위가 가비지 컬렉션의 한 형태지만 여기서는 순환 참조가 발생했을 때 cyclic garbage collector를 통한 <strong>가비지 컬렉션</strong>과 <strong>레퍼런스 카운팅</strong>을 통한 가비지 컬렉션을 구분했다.</p>
</blockquote>
<p>여기서 '순환 참조가 발생한 건 어떻게 탐지하지?', '주기적으로 감시한다면 그 주기의 기준은 뭘까?', '가비지 컬렉션은 언제 발생하지?' 같은 의문이 들 수 있는데 이 의문을 해결하기 전에 잠시 레퍼런스 카운팅, 순환 참조, 파이썬의 가비지 컬렉터에 대한 간단한 개념을 짚고 넘어가자. 이 개념을 알고 있다면 바로 <a href="#2-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98%EC%9D%98-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D">가비지 컬렉션의 작동 방식 단락</a>을 읽으면 된다.</p>
<h2>1. 개념 잡기</h2>
<h3>1.1. 레퍼런스 카운팅</h3>
<p>모든 객체는 참조 당할 때 레퍼런스 카운터를 증가시키고 참조가 없어질 때 카운터를 감소시킨다. 이 카운터가 0이 되면 객체가 메모리에서 해제한다. 어떤 객체의 레퍼런스 카운트를 보고 싶다면 <code>sys.getrefcount()</code>로 확인할 수 있다.</p>
<details>
    <summary>
        <code class="highlighter-rouge">Py_INCREF()</code>와
        <code class="highlighter-rouge">Py_DECREF()</code>를 통한 카운터 증감
    </summary>
<br>
<p>
    카운터를 증감시키는 명령은 아래와 같이
    <a href="https://github.com/python/cpython/blob/master/Include/object.h">object.h</a>에 선언되어있는데 카운터를 증가시킬 때는 단순히
    <code class="highlighter-rouge">ob_refcnt</code>를 1 증가시키고 감소시킬 때는 1 감소시킴과 동시에 카운터가 0이 되면 메모리에서 객체를 해제하는 것을 확인할 수 있다.
</p>
<div class="language-c# highlighter-rouge">
    <div class="highlight">
<pre class="highlight">
<code>
<span class="nf">#define</span> Py_INCREF(op) (                         <span class="cp">\</span>
    <span class="n">_Py_INC_REFTOTAL</span>  <span class="n">_Py_REF_DEBUG_COMMA</span>       <span class="cp">\</span>
    <span class="p">((</span><span class="n">PyObject</span> <span class="p">*)(</span><span class="n">op</span><span class="p">))</span><span class="o">-&gt;</span><span class="nf">ob_refcnt</span><span class="o">++</span><span class="p">)</span>
<p><span class="nf">#define</span> Py_DECREF(op)                                   <span class="cp"><br>
</span>    <span class="k">do</span> <span class="p">{</span>                                                <span class="cp">&#x3C;/span>
<span class="n">PyObject</span> <span class="p"><em></span><span class="n">_py_decref_tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyObject</span> <span class="p"></em>)(</span><span class="n">op</span><span class="p">);</span>    <span class="cp">&#x3C;/span>
<span class="k">if</span> <span class="p">(</span><span class="n">_Py_DEC_REFTOTAL</span>  <span class="n">_Py_REF_DEBUG_COMMA</span>       <span class="cp">&#x3C;/span>
<span class="o">--</span><span class="p">(</span><span class="n">_py_decref_tmp</span><span class="p">)</span><span class="o">-></span><span class="nf">ob_refcnt</span> <span class="o">!=</span> <span class="m">0</span><span class="p">)</span>             <span class="cp">&#x3C;/span>
<span class="nf">_Py_CHECK_REFCNT</span><span class="p">(</span><span class="n">_py_decref_tmp</span><span class="p">)</span>            <span class="cp">&#x3C;/span>
<span class="k">else</span>                                            <span class="cp">&#x3C;/span>
<span class="nf">_Py_Dealloc</span><span class="p">(</span><span class="n">_py_decref_tmp</span><span class="p">);</span>                <span class="cp">&#x3C;/span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="m">0</span><span class="p">)</span></p>
</code>
</pre>
    </div>
</div>
<p>더 정확한 정보는
    <a href="https://docs.python.org/3/extending/extending.html#reference-counting-in-python">파이썬 공식 문서</a>를 참고하면 자세하게 설명되어있다.
</p>
<hr>
</details>
<h3>1.2. 순환 참조</h3>
<p>순환 참조의 간단한 예제는 자기 자신을 참조하는 객체다.</p>
<pre><code class="language-python">>>> l = []
>>> l.append(l)
>>> del l
</code></pre>
<p><code>l</code>의 참조 횟수는 1이지만 이 객체는 더 이상 접근할 수 없으며 레퍼런스 카운팅 방식으로는 메모리에서 해제될 수 없다.</p>
<p>또 다른 예로는 서로를 참조하는 객체다.</p>
<pre><code class="language-python">>>> a = Foo()  # 0x60
>>> b = Foo()  # 0xa8
>>> a.x = b  # 0x60의 x는 0xa8를 가리킨다.
>>> b.x = a  # 0xa8의 x는 0x60를 가리킨다.
# 이 시점에서 0x60의 레퍼런스 카운터는 a와 b.x로 2
# 0xa8의 레퍼런스 카운터는 b와 a.x로 2다.
>>> del a  # 0x60은 1로 감소한다. 0xa8은 b와 0x60.x로 2다.
>>> del b  # 0xa8도 1로 감소한다.
</code></pre>
<p>이 상태에서 <code>0x60.x</code>와 <code>0xa8.x</code>가 서로를 참조하고 있기 때문에 레퍼런스 카운트는 둘 다 1이지만 도달할 수 없는 가비지가 된다.</p>
<h3>1.3. 가비지 컬렉터</h3>
<p>파이썬의 <code>gc</code> 모듈을 통해 가비지 컬렉터를 직접 제어할 수 있다. <code>gc</code> 모듈은 <a href="https://docs.python.org/3/c-api/gcsupport.html">cyclic garbage collection을 지원</a>하는데 이를 통해 reference cycles(순환 참조)를 해결할 수 있다. gc모듈은 오로지 순환 참조를 탐지하고 해결하기 위해 존재한다. <a href="https://docs.python.org/3/library/gc.html"><code>gc</code> 파이썬 공식문서</a>에서도 순환 참조를 만들지 않는다고 확신할 수 있으면 <code>gc.disable()</code>을 통해 garbage collector를 비활성화시켜도 된다고 언급하고 있다.</p>
<blockquote>
<p>Since the collector supplements the reference counting already used in Python, you can disable the collector if you are sure your program does not create reference cycles.</p>
</blockquote>
<h2>2. 가비지 컬렉션의 작동 방식</h2>
<p>순환 참조 상태도 해결할 수 있는 cyclic garbage collection이 어떤 방식으로 동작하는지는 결국 <strong>어떤 기준으로 가비지 컬렉션이 발생</strong>하고 <strong>어떻게 순환 참조를 감지</strong>하는지에 관한 내용이다. 이에 대해 차근차근 알아보자.</p>
<h3>2.1. 어떤 기준으로 가비지 컬렉션이 일어나는가</h3>
<p>앞에서 제기했던 의문은 결국 발생 기준에 관한 의문이다. 가비지 컬렉터는 내부적으로 <code>generation</code>(세대)과 <code>threshold</code>(임계값)로 가비지 컬렉션 주기와 객체를 관리한다. 세대는 0세대, 1세대, 2세대로 구분되는데 최근에 생성된 객체는 0세대(young)에 들어가고 오래된 객체일수록 2세대(old)에 존재한다. 더불어 한 객체는 단 하나의 세대에만 속한다. 가비지 컬렉터는 0세대일수록 더 자주 가비지 컬렉션을 하도록 설계되었는데 이는 <a href="http://www.memorymanagement.org/glossary/g.html#term-generational-hypothesis">generational hypothesis</a>에 근거한다.</p>
<details>
    <summary>generational hypothesis의 두 가지 가설</summary>
<br>
<ul>
    <li>대부분의 객체는 금방 도달할 수 없는 상태(unreachable)가 된다.</li>
    <li>오래된 객체(old)에서 젊은 객체(young)로의 참조는 아주 적게 존재한다.</li>
</ul>
<p>
    <img src="https://plumbr.io/wp-content/uploads/2015/05/object-age-based-on-GC-generation-generational-hypothesis.png" alt="">
    <br>
    <sup>
        <em>출처
            <a href="https://plumbr.io/handbook/garbage-collection-in-java/generational-hypothesis">plumbr.io</a>
        </em>
    </sup>
</p>
<ul>
    <li>
        <a href="http://d2.naver.com/helloworld/1329">Reference: Naver D2 - Java Garbage Collection</a>
    </li>
</ul>
<hr>
</details>
<p>주기는 threshold와 관련 있는데 <code>gc.get_threshold()</code>로 확인해 볼 수 있다.</p>
<pre><code class="language-python">>>> gc.get_threshold()
(700, 10, 10)
</code></pre>
<p>각각 <code>threshold 0</code>, <code>threshold 1</code>, <code>threshold 2</code>를 의미하는데 n세대에 객체를 할당한 횟수가 <code>threshold n</code>을 초과하면 가비지 컬렉션이 수행되며 이 값은 변경될 수 있다.</p>
<p>0세대의 경우 메모리에 객체가 할당된 횟수에서 해제된 횟수를 뺀 값, 즉 객체 수가 <code>threshold 0</code>을 초과하면 실행된다. 다만 그 이후 세대부터는 조금 다른데 0세대 가비지 컬렉션이 일어난 후 0세대 객체를 1세대로 이동시킨 후 카운터를 1 증가시킨다. 이 1세대 카운터가 <code>threshold 1</code>을 초과하면 그때 1세대 가비지 컬렉션이 일어난다. 비약시켜서 0세대 가비지 컬렉션이 객체 생성 700번만에 일어난다면 1세대는 7000번만에, 2세대는 7만번만에 일어난다는 뜻이다.</p>
<p>이를 말로 풀어서 설명하려니 조금 복잡해졌지만 간단하게 말하면 메모리 할당시 <code>generation[0].count++</code>, 해제시 <code>generation[0].count--</code>가 발생하고, <code>generation[0].count > threshold[0]</code>이면 <code>genereation[0].count = 0</code>, <code>generation[1].count++</code>이 발생하고 <code>generation[1].count > 10</code>일 때 0세대, 1세대 count를 0으로 만들고 <code>generation[2].count++</code>을 한다는 뜻이다.</p>
<p><a href="https://github.com/python/cpython/blob/master/Modules/gcmodule.c#L832-L836">gcmodule.c 코드로 보기</a></p>
<h3>2.2. 라이프 사이클</h3>
<p>이렇듯 가비지 컬렉터는 세대와 임계값을 통해 가비지 컬렉션의 주기를 관리한다. 이제 가비지 컬렉터가 어떻게 순환 참조를 발견하는지 알아보기에 앞서 가비지 컬렉션의 실행 과정(라이프 사이클)을 간단하게 알아보자.</p>
<p>새로운 객체가 만들어질때 파이썬은 객체를 메모리와 0세대에 할당한다. 만약 0세대의 객체 수가 <code>threshold 0</code>보다 크면 <code>collect_generations()</code>를 실행한다.</p>
<details>
    <summary>코드와 함께하는 더 자세한 설명</summary>
<br>
<p>새로운 객체가 만들어 질 때 파이썬은
    <code class="highlighter-rouge">_PyObject_GC_Alloc()</code>을 호출한다. 이 메서드는 객체를 메모리에 할당하고, 가비지 컬렉터의 0세대의 카운터를 증가시킨다. 그 다음 0세대의 객체 수가
    <code class="highlighter-rouge">threshold 0</code>보다 큰지,
    <code class="highlighter-rouge">gc.enabled</code>가 true인지,
    <code class="highlighter-rouge">threshold 0</code>이 0이 아닌지, 가비지 컬렉션 중이 아닌지 확인하고, 모든 조건을 만족하면
    <code class="highlighter-rouge">collect_generations()</code>를 실행한다.
</p>
<p>다음은
    <code class="highlighter-rouge">_PyObject_GC_Alloc()</code>을 간략화 한 소스며 메서드 전체 내용은
    <a href="https://github.com/python/cpython/blob/master/Modules/gcmodule.c#L1681-L1710">여기</a>에서 확인할 수 있다.
</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">_PyObject_GC_Alloc</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ...
</span>
    <span class="n">gc</span><span class="p">.</span><span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* 0세대 카운터 증가 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">gc</span><span class="p">.</span><span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">gc</span><span class="p">.</span><span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">threshold</span> <span class="o">&amp;&amp;</span> <span class="cm">/* 임계값을 초과하며 */</span>
        <span class="n">gc</span><span class="p">.</span><span class="n">enabled</span> <span class="o">&amp;&amp;</span>  <span class="cm">/* 사용가능하며 */</span>
        <span class="n">gc</span><span class="p">.</span><span class="n">generations</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">threshold</span> <span class="o">&amp;&amp;</span>  <span class="cm">/* 임계값이 0이 아니고 */</span>
        <span class="o">!</span><span class="n">gc</span><span class="p">.</span><span class="n">collecting</span><span class="p">)</span>  <span class="cm">/* 컬렉션 중이 아니면 */</span>
    <span class="p">{</span>
        <span class="n">gc</span><span class="p">.</span><span class="n">collecting</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">collect_generations</span><span class="p">();</span>
        <span class="n">gc</span><span class="p">.</span><span class="n">collecting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ...
</span><span class="p">}</span>
</code></pre></div></div>
<p>참고로
    <code class="highlighter-rouge">gc</code>를 끄고싶으면
    <code class="highlighter-rouge">gc.disable()</code>보단
    <code class="highlighter-rouge">gc.set_threshold(0)</code>이 더 확실하다.
    <code class="highlighter-rouge">disable()</code>의 경우 서드 파티 라이브러리에서
    <code class="highlighter-rouge">enable()</code>하는 경우가 있다고 한다.
</p>
<hr>
</details>
<p><code>collect_generations()</code> 메서드가 호출되면 모든 세대(기본적으로 3개의 세대)를 검사하는데 가장 오래된 세대(2세대)부터 역으로 확인한다. 해당 세대에 객체가 할당된 횟수가 각 세대에 대응되는 <code>threshold n</code>보다 크면 <code>collect()</code>를 호출해 가비지 컬렉션을 수행한다.</p>
<details>
    <summary>코드</summary>
<br>
<p>
    <code class="highlighter-rouge">collect()</code>가 호출될 때 해당 세대보다 어린 세대들은 모두 통합되어 가비지 컬렉션이 수행되기 때문에
    <code class="highlighter-rouge">break</code>를 통해 검사를 중단한다.
</p>
<p>다음은
    <code class="highlighter-rouge">collect_generations()</code>을 간략화 한 소스며 메서드 전체 내용은
    <a href="https://github.com/python/cpython/blob/master/Modules/gcmodule.c#L1020-L1056">여기</a>에서 확인할 수 있다.
</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">Py_ssize_t</span>
<span class="nf">collect_generations</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">NUM_GENERATIONS</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">gc</span><span class="p">.</span><span class="n">generations</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">gc</span><span class="p">.</span><span class="n">generations</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">threshold</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">collect_with_callback</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<p><span class="k">static</span> <span class="n">Py_ssize_t</span>
<span class="nf">collect_with_callback</span><span class="p">(</span><span class="kt">int</span> <span class="n">generation</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">// ...
</span>    <span class="n">result</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">generation</span><span class="p">,</span> <span class="o">&#x26;</span><span class="n">collected</span><span class="p">,</span> <span class="o">&#x26;</span><span class="n">uncollectable</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="c1">// ...
</span><span class="p">}</span>
</code></pre></div></div></p>
<hr>
</details>
<p><code>collect()</code> 메서드는 <strong>순환 참조 탐지 알고리즘</strong>을 수행하고 특정 세대에서 도달할 수 있는 객체(reachable)와 도달할 수 없는 객체(unreachable)를 구분하고 도달할 수 없는 객체 집합을 찾는다. 도달할 수 있는 객체 집합은 다음 상위 세대로 합쳐지고(0세대에서 수행되었으면 1세대로 이동), 도달할 수 없는 객체 집합은 콜백을 수행한 후 메모리에서 해제된다.</p>
<p>이제 정말 <strong>순환 참조 탐지 알고리즘</strong>을 알아볼 때가 됐다.</p>
<h3>2.3. 어떻게 순환 참조를 감지하는가</h3>
<p>먼저 순환 참조는 컨테이너 객체(e.g. <code>tuple</code>, <code>list</code>, <code>set</code>, <code>dict</code>, <code>class</code>)에 의해서만 발생할 수 있음을 알아야 한다. 컨테이너 객체는 다른 객체에 대한 참조를 보유할 수 있다. 그러므로 정수, 문자열은 무시한 채 관심사를 컨테이너 객체에만 집중할 수 있다.</p>
<p>순환 참조를 해결하기 위한 아이디어로 모든 컨테이너 객체를 추적한다. 여러 방법이 있겠지만 객체 내부의 링크 필드에 더블 링크드 리스트를 사용하는 방법이 가장 좋다. 이렇게 하면 추가적인 메모리 할당 없이도 <strong>컨테이너 객체 집합</strong>에서 객체를 빠르게 추가하고 제거할 수 있다. 컨테이너 객체가 생성될 때 이 집합에 추가되고 제거될 때 집합에서 삭제된다.</p>
<details>
    <summary>
        <code class="highlighter-rouge">PyGC_Head</code>에 선언된 더블 링크드 리스트
    </summary>
<br>
<p>더블 링크드 리스트는 다음과 같이 선언되어 있으며
    <a href="https://github.com/python/cpython/blob/master/Include/objimpl.h#L250-L259">objimpl.h 코드</a>에서 확인해볼 수 있다.
</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">#ifndef</span> <span class="p">Py_LIMITED_API
</span><span class="k">typedef</span> <span class="k">union</span> <span class="n">_gc_head</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="p">{</span>
        <span class="k">union</span> <span class="n">_gc_head</span> <span class="o">*</span><span class="n">gc_next</span><span class="p">;</span>
        <span class="k">union</span> <span class="n">_gc_head</span> <span class="o">*</span><span class="n">gc_prev</span><span class="p">;</span>
        <span class="n">Py_ssize_t</span> <span class="n">gc_refs</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">gc</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">dummy</span><span class="p">;</span>  <span class="cm">/* force worst-case alignment */</span>
<span class="p">}</span> <span class="n">PyGC_Head</span><span class="p">;</span>
</code></pre></div></div>
<hr>
</details>
<p>이제 모든 컨테이너 객체에 접근할 수 있으니 순환 참조를 찾을 수 있어야 한다. 순환 참조를 찾는 과정은 다음과 같다.</p>
<ol>
<li>객체에 <code>gc_refs</code> 필드를 레퍼런스 카운트와 같게 설정한다.</li>
<li>각 객체에서 참조하고 있는 다른 컨테이너 객체를 찾고, 참조되는 컨테이너의 <code>gc_refs</code>를 감소시킨다.</li>
<li><code>gc_refs</code>가 0이면 그 객체는 컨테이너 집합 내부에서 자기들끼리 참조하고 있다는 뜻이다.</li>
<li>그 객체를 unreachable 하다고 표시한 뒤 메모리에서 해제한다.</li>
</ol>
<p>이제 우리는 가비지 컬렉터가 어떻게 순환 참조 객체를 탐지하고 메모리에서 해제하는지 알았다.</p>
<h2>3. 예제</h2>
<blockquote>
<p>아래 예제는 보기 쉽게 가공한 예제이며 실제 <code>collect()</code>의 동작과는 차이가 있다. 정확한 작동 방식은 아래에서 다시 서술한다. 혹은 <a href="https://github.com/python/cpython/blob/master/Modules/gcmodule.c#L797-L981"><code>collect()</code> 코드</a>를 참고하자.</p>
</blockquote>
<p>아래의 예제를 통해 가비지 컬렉터가 어떤 방법으로 순환 참조 객체인 <code>Foo(0)</code>과 <code>Foo(1)</code>을 해제하는지 알아보겠다.</p>
<pre><code class="language-python">a = [1]
# Set: a:[1]
b = ['a']
# Set: a:[1] &#x3C;-> b:['a']
c = [a, b]
# Set: a:[1] &#x3C;-> b:['a'] &#x3C;-> c:[a, b]
d = c
# Set: a:[1] &#x3C;-> b:['a'] &#x3C;-> c,d:[a, b]
# 컨테이너 객체가 생성되지 않았기에 레퍼런스 카운트만 늘어난다.
e = Foo(0)
# Set: a:[1] &#x3C;-> b:['a'] &#x3C;-> c,d:[a, b] &#x3C;-> e:Foo(0)
f = Foo(1)
# Set: a:[1] &#x3C;-> b:['a'] &#x3C;-> c,d:[a, b] &#x3C;-> e:Foo(0) &#x3C;-> f:Foo(1)
e.x = f
# Set: a:[1] &#x3C;-> b:['a'] &#x3C;-> c,d:[a, b] &#x3C;-> e:Foo(0) &#x3C;-> f,Foo(0).x:Foo(1)
f.x = e
# Set: a:[1] &#x3C;-> b:['a'] &#x3C;-> c,d:[a, b] &#x3C;-> e,Foo(1).x:Foo(0) &#x3C;-> f,Foo(0).x:Foo(1)
del e
# Set: a:[1] &#x3C;-> b:['a'] &#x3C;-> c,d:[a, b] &#x3C;-> Foo(1).x:Foo(0) &#x3C;-> f,Foo(0).x:Foo(1)
del f
# Set: a:[1] &#x3C;-> b:['a'] &#x3C;-> c,d:[a, b] &#x3C;-> Foo(1).x:Foo(0) &#x3C;-> Foo(0).x:Foo(1)
</code></pre>
<p>위 상황에서 각 컨테이너 객체의 레퍼런스 카운트는 다음과 같다.</p>
<pre><code class="language-py"># ref count
[1]     &#x3C;- a,c      = 2
['a']   &#x3C;- b,c      = 2
[a, b]  &#x3C;- c,d      = 2
Foo(0)  &#x3C;- Foo(1).x = 1
Foo(1)  &#x3C;- Foo(0).x = 1
</code></pre>
<p>1번 과정에서 각 컨테이너 객체의 <code>gc_refs</code>가 설정된다.</p>
<pre><code class="language-py"># gc_refs
[1]    = 2
['a']  = 2
[a, b] = 2
Foo(0) = 1
Foo(1) = 1
</code></pre>
<p>2번 과정에서 컨테이너 집합을 순회하며 <code>gc_refs</code>을 감소시킨다.</p>
<pre><code class="language-py">[1]     = 1  # [a, b]에 의해 참조당하므로 1 감소
['a']   = 1  # [a, b]에 의해 참조당하므로 1 감소
[a, b]  = 2  # 참조당하지 않으므로 그대로
Foo(0)  = 0  # Foo(1)에 의해 참조당하므로 1 감소
Foo(1)  = 0  # Foo(0)에 의해 참조당하므로 1 감소
</code></pre>
<p>3번 과정을 통해 <code>gc_refs</code>가 0인 순환 참조 객체를 발견했다. 이제 이 객체를 unreachable 집합에 옮겨주자.</p>
<pre><code class="language-py"> unreachable |  reachable
             |    [1] = 1
 Foo(0) = 0  |  ['a'] = 1
 Foo(1) = 0  | [a, b] = 2
</code></pre>
<p>이제 <code>Foo(0)</code>와 <code>Foo(1)</code>을 메모리에서 해제하면 가비지 컬렉션 과정이 끝난다.</p>
<h2>4. 더 정확하고 자세한 설명</h2>
<p><code>collect()</code> 메서드는 현재 세대와 어린 세대를 합쳐 순환 참조를 검사한다. 이 합쳐진 세대를 <code>young</code>으로 이름 붙이고 다음의 과정을 거치며 최종적으로 도달할 수 없는 객체가 모인 unreachable 리스트를 메모리에서 해제하고 young에 남아있는 객체를 다음 세대에 할당한다.</p>
<pre><code class="language-c">update_refs(young)
subtract_refs(young)
gc_init_list(&#x26;unreachable)
move_unreachable(young, &#x26;unreachable)
</code></pre>
<p><code>update_refs()</code>는 모든 객체의 레퍼런스 카운트 사본을 만든다. 이는 가비지 컬렉터가 실제 레퍼런스 카운트를 건드리지 않게 하기 위함이다.</p>
<p><code>subtract_refs()</code>는 각 객체 i에 대해 i에 의해 참조되는 객체 j의 <code>gc_refs</code>를 감소시킨다. 이 과정이 끝나면 (young 세대에 남아있는 객체의 레퍼런스 카운트) - (남아있는 <code>gc_refs</code>) 값이 old 세대에서 young 세대를 참조하는 수와 같다.</p>
<p><code>move_unreachable()</code> 메서드는 young 세대를 스캔하며 <code>gc_refs</code>가 0인 객체를 <code>unreachable</code> 리스트로 이동시키고 <code>GC_TENTATIVELY_UNREACHABLE</code>로 설정한다. 왜 완전히 <code>unreachable</code>이 아닌 임시로(Tentatively) 설정하냐면 나중에 스캔 될 객체로부터 도달할 수도 있기 때문이다.</p>
<details>
    <summary>예제 보기</summary>
<br>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">b</span>
<span class="n">b</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">a</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">b</span>
<span class="k">del</span> <span class="n">a</span>
<span class="k">del</span> <span class="n">b</span>
<p><span class="c"># 위 상황을 요약하면 다음과 같다.</span>
<span class="n">Foo</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div></p>
<p>이때 상황은 다음과 같은데
    <code class="highlighter-rouge">Foo(0)</code>의
    <code class="highlighter-rouge">gc_refs</code>가 0이어도 뒤에 나올
    <code class="highlighter-rouge">Foo(1)</code>을 통해 도달할 수 있다.
</p>
<table>
  <thead>
    <tr>
      <th style="text-align: center">young</th>
      <th style="text-align: center">ref count</th>
      <th style="text-align: center">gc_refs</th>
      <th style="text-align: center">reachable</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><code class="highlighter-rouge">Foo(0)</code></td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center"><code class="highlighter-rouge">c.x</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="highlighter-rouge">Foo(1)</code></td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center"><code class="highlighter-rouge">c</code></td>
    </tr>
  </tbody>
</table>
<hr>
</details>
<p>0이 아닌 객체는 <code>GC_REACHABLE</code>로 설정하고 그 객체가 참조하고 있는 객체 또한 찾아가(traverse) <code>GC_REACHABLE</code>로 설정한다. 만약 그 객체가 <code>unreachable</code> 리스트에 있던 객체라면 <code>young</code> 리스트의 끝으로 보낸다. 굳이 <code>young</code>의 끝으로 보내는 이유는 그 객체 또한 다른 <code>gc_refs</code>가 0인 객체를 참조하고 있을 수 있기 때문이다.</p>
<details>
    <summary>예제 보기</summary>
<br>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">a</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">b</span>
<span class="n">b</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">a</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">b</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">d</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">d</span>
<span class="n">a</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">d</span>
<span class="k">del</span> <span class="n">d</span>
<span class="k">del</span> <span class="n">a</span>
<span class="k">del</span> <span class="n">b</span>
<p><span class="c"># 위 상황을 요약하면 다음과 같다.</span>
<span class="n">Foo</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Foo</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div></p>
<table>
  <thead>
    <tr>
      <th style="text-align: center">young</th>
      <th style="text-align: center">ref count</th>
      <th style="text-align: center">gc_refs</th>
      <th style="text-align: center">reachable</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><code class="highlighter-rouge">Foo(0)</code></td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center"><code class="highlighter-rouge">c.x</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="highlighter-rouge">Foo(1)</code></td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center"><code class="highlighter-rouge">c</code></td>
    </tr>
    <tr>
      <td style="text-align: center"><code class="highlighter-rouge">Foo(2)</code></td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center"><code class="highlighter-rouge">c.x.y</code></td>
    </tr>
  </tbody>
</table>
<p>이 상황에서
    <code class="highlighter-rouge">Foo(0)</code>은
    <code class="highlighter-rouge">unreachable</code> 리스트에 있다가
    <code class="highlighter-rouge">Foo(1)</code>을 조사하며 다시
    <code class="highlighter-rouge">young</code> 리스트의 맨 뒤로 돌아왔고,
    <code class="highlighter-rouge">Foo(2)</code>도
    <code class="highlighter-rouge">unreachable</code> 리스트에 갔지만, 곧
    <code class="highlighter-rouge">Foo(0)</code>에 의해 참조될 수 있음을 알고 다시
    <code class="highlighter-rouge">young</code> 리스트로 돌아온다.
</p>
<hr>
</details>
<p><code>young</code> 리스트의 전체 스캔이 끝나면 이제 <code>unreachable</code> 리스트에 있는 객체는 <strong>정말 도달할 수 없다</strong>. 이제 이 객체들을 메모리에서 해제되고 <code>young</code> 리스트의 객체들은 상위 세대로 합쳐진다.</p>
<h2>5. Reference</h2>
<ul>
<li><a href="https://b.luavis.kr/python/dismissing-python-garbage-collection-at-instagram">Instagram이 gc를 없앤 이유</a></li>
<li><a href="http://weicomes.tistory.com/277">파이썬 Garbage Collection</a></li>
<li><a href="https://www.kylev.com/2009/11/03/finding-my-first-python-reference-cycle/">Finding reference cycle</a></li>
<li><a href="http://d2.naver.com/helloworld/1329">Naver D2 - Java Garbage Collection</a></li>
<li><a href="https://docs.python.org/3/library/gc.html#gc.set_threshold">gc의 threshold</a></li>
</ul>
<p>아래의 링크는 특히 큰 도움이 되었다.</p>
<ul>
<li><a href="http://www.arctrix.com/nas/python/gc/">Garbage Collection for Python</a></li>
<li><a href="https://www.quora.com/How-does-garbage-collection-in-Python-work-What-are-the-pros-and-cons">How does garbage collection in Python work</a></li>
<li><a href="https://github.com/python/cpython/blob/master/Modules/gcmodule.c">gcmodule.c</a></li>
</ul>
<p>잘못된 정보, 오타 혹은 보완할 점이 있으면 <a href="https://twitter.com/res_tin">트위터</a>, <a href="mailto:wintermy201@gmail.com">메일</a> 등으로 알려주시면 감사하겠습니다.</p></div></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-GHDZ9WX1EH"></script><script>
      
      
      if(true) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-GHDZ9WX1EH', {"send_page_view":false});
      }
      </script><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/python-gc/";/*]]>*/</script><!-- slice-start id="_gatsby-scripts-1" -->
          <script
            id="gatsby-chunk-mapping"
          >
            window.___chunkMapping="{\"app\":[\"/app-2de8dd80665bcb02167b.js\"],\"component---src-pages-404-jsx\":[\"/component---src-pages-404-jsx-2e46b0aedfddc9ed0d72.js\"],\"component---src-pages-index-jsx\":[\"/component---src-pages-index-jsx-a3f57e32931f87b809ea.js\"],\"component---src-pages-my-files-jsx\":[\"/component---src-pages-my-files-jsx-e3918b5adbccab2e288d.js\"],\"component---src-templates-post-jsx\":[\"/component---src-templates-post-jsx-8e21b8079b44f8d9ec12.js\"]}";
          </script>
        <script>window.___webpackCompilationHash="f2cff95366a5da3cb373";</script><script src="/webpack-runtime-ef87f0342182738b6f71.js" async></script><script src="/framework-1f1ec840701ba3409b52.js" async></script><script src="/app-2de8dd80665bcb02167b.js" async></script><!-- slice-end id="_gatsby-scripts-1" --></body></html>