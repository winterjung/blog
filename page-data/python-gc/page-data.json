{"componentChunkName":"component---src-templates-post-jsx","path":"/python-gc/","result":{"data":{"markdownRemark":{"html":"<p>보통 파이썬은 레퍼런스 카운팅 방식으로 가비지 컬렉션을 수행해 메모리를 관리하고, 레퍼런스 카운팅을 사용했을 때 발생할 수 있는 순환 참조 상황을 별도의 가비지 컬렉터로 해결한다고 알고 있다. 이 글에서는 그 가비지 컬렉터가 어떤 방식으로 작동하는지를 깊게 알아보고자 한다.</p>\n<blockquote>\n<p>이 글은 CPython을 기준으로 작성되었다.</p>\n</blockquote>\n<h2>0. GC는 어떨 때 사용하는가</h2>\n<p>파이썬에선 기본적으로 <a href=\"https://docs.python.org/3/glossary.html#term-garbage-collection\">garbage collection</a>(가비지 컬렉션)과 <a href=\"https://docs.python.org/3/glossary.html#term-reference-count\">reference counting</a>(레퍼런스 카운팅)을 통해 할당된 메모리를 관리한다. 기본적으로 참조 횟수가 0이 된 객체를 메모리에서 해제하는 레퍼런스 카운팅 방식을 사용하지만, 참조 횟수가 0은 아니지만 도달할 수 없지만, 상태인 reference cycles(순환 참조)가 발생했을 때는 가비지 컬렉션으로 그 상황을 해결한다.</p>\n<blockquote>\n<p>엄밀히 말하면 레퍼런스 카운팅 방식을 통해 객체를 메모리에서 해제하는 행위가 가비지 컬렉션의 한 형태지만 여기서는 순환 참조가 발생했을 때 cyclic garbage collector를 통한 <strong>가비지 컬렉션</strong>과 <strong>레퍼런스 카운팅</strong>을 통한 가비지 컬렉션을 구분했다.</p>\n</blockquote>\n<p>여기서 '순환 참조가 발생한 건 어떻게 탐지하지?', '주기적으로 감시한다면 그 주기의 기준은 뭘까?', '가비지 컬렉션은 언제 발생하지?' 같은 의문이 들 수 있는데 이 의문을 해결하기 전에 잠시 레퍼런스 카운팅, 순환 참조, 파이썬의 가비지 컬렉터에 대한 간단한 개념을 짚고 넘어가자. 이 개념을 알고 있다면 바로 <a href=\"#2-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98%EC%9D%98-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D\">가비지 컬렉션의 작동 방식 단락</a>을 읽으면 된다.</p>\n<h2>1. 개념 잡기</h2>\n<h3>1.1. 레퍼런스 카운팅</h3>\n<p>모든 객체는 참조 당할 때 레퍼런스 카운터를 증가시키고 참조가 없어질 때 카운터를 감소시킨다. 이 카운터가 0이 되면 객체가 메모리에서 해제한다. 어떤 객체의 레퍼런스 카운트를 보고 싶다면 <code>sys.getrefcount()</code>로 확인할 수 있다.</p>\n<details>\n    <summary>\n        <code class=\"highlighter-rouge\">Py_INCREF()</code>와\n        <code class=\"highlighter-rouge\">Py_DECREF()</code>를 통한 카운터 증감\n    </summary>\n<br>\n<p>\n    카운터를 증감시키는 명령은 아래와 같이\n    <a href=\"https://github.com/python/cpython/blob/master/Include/object.h\">object.h</a>에 선언되어있는데 카운터를 증가시킬 때는 단순히\n    <code class=\"highlighter-rouge\">ob_refcnt</code>를 1 증가시키고 감소시킬 때는 1 감소시킴과 동시에 카운터가 0이 되면 메모리에서 객체를 해제하는 것을 확인할 수 있다.\n</p>\n<div class=\"language-c# highlighter-rouge\">\n    <div class=\"highlight\">\n<pre class=\"highlight\">\n<code>\n<span class=\"nf\">#define</span> Py_INCREF(op) (                         <span class=\"cp\">\\</span>\n    <span class=\"n\">_Py_INC_REFTOTAL</span>  <span class=\"n\">_Py_REF_DEBUG_COMMA</span>       <span class=\"cp\">\\</span>\n    <span class=\"p\">((</span><span class=\"n\">PyObject</span> <span class=\"p\">*)(</span><span class=\"n\">op</span><span class=\"p\">))</span><span class=\"o\">-&gt;</span><span class=\"nf\">ob_refcnt</span><span class=\"o\">++</span><span class=\"p\">)</span>\n<p><span class=\"nf\">#define</span> Py_DECREF(op)                                   <span class=\"cp\"><br>\n</span>    <span class=\"k\">do</span> <span class=\"p\">{</span>                                                <span class=\"cp\">&#x3C;/span>\n<span class=\"n\">PyObject</span> <span class=\"p\"><em></span><span class=\"n\">_py_decref_tmp</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">PyObject</span> <span class=\"p\"></em>)(</span><span class=\"n\">op</span><span class=\"p\">);</span>    <span class=\"cp\">&#x3C;/span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">_Py_DEC_REFTOTAL</span>  <span class=\"n\">_Py_REF_DEBUG_COMMA</span>       <span class=\"cp\">&#x3C;/span>\n<span class=\"o\">--</span><span class=\"p\">(</span><span class=\"n\">_py_decref_tmp</span><span class=\"p\">)</span><span class=\"o\">-></span><span class=\"nf\">ob_refcnt</span> <span class=\"o\">!=</span> <span class=\"m\">0</span><span class=\"p\">)</span>             <span class=\"cp\">&#x3C;/span>\n<span class=\"nf\">_Py_CHECK_REFCNT</span><span class=\"p\">(</span><span class=\"n\">_py_decref_tmp</span><span class=\"p\">)</span>            <span class=\"cp\">&#x3C;/span>\n<span class=\"k\">else</span>                                            <span class=\"cp\">&#x3C;/span>\n<span class=\"nf\">_Py_Dealloc</span><span class=\"p\">(</span><span class=\"n\">_py_decref_tmp</span><span class=\"p\">);</span>                <span class=\"cp\">&#x3C;/span>\n<span class=\"p\">}</span> <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"m\">0</span><span class=\"p\">)</span></p>\n</code>\n</pre>\n    </div>\n</div>\n<p>더 정확한 정보는\n    <a href=\"https://docs.python.org/3/extending/extending.html#reference-counting-in-python\">파이썬 공식 문서</a>를 참고하면 자세하게 설명되어있다.\n</p>\n<hr>\n</details>\n<h3>1.2. 순환 참조</h3>\n<p>순환 참조의 간단한 예제는 자기 자신을 참조하는 객체다.</p>\n<pre><code class=\"language-python\">>>> l = []\n>>> l.append(l)\n>>> del l\n</code></pre>\n<p><code>l</code>의 참조 횟수는 1이지만 이 객체는 더 이상 접근할 수 없으며 레퍼런스 카운팅 방식으로는 메모리에서 해제될 수 없다.</p>\n<p>또 다른 예로는 서로를 참조하는 객체다.</p>\n<pre><code class=\"language-python\">>>> a = Foo()  # 0x60\n>>> b = Foo()  # 0xa8\n>>> a.x = b  # 0x60의 x는 0xa8를 가리킨다.\n>>> b.x = a  # 0xa8의 x는 0x60를 가리킨다.\n# 이 시점에서 0x60의 레퍼런스 카운터는 a와 b.x로 2\n# 0xa8의 레퍼런스 카운터는 b와 a.x로 2다.\n>>> del a  # 0x60은 1로 감소한다. 0xa8은 b와 0x60.x로 2다.\n>>> del b  # 0xa8도 1로 감소한다.\n</code></pre>\n<p>이 상태에서 <code>0x60.x</code>와 <code>0xa8.x</code>가 서로를 참조하고 있기 때문에 레퍼런스 카운트는 둘 다 1이지만 도달할 수 없는 가비지가 된다.</p>\n<h3>1.3. 가비지 컬렉터</h3>\n<p>파이썬의 <code>gc</code> 모듈을 통해 가비지 컬렉터를 직접 제어할 수 있다. <code>gc</code> 모듈은 <a href=\"https://docs.python.org/3/c-api/gcsupport.html\">cyclic garbage collection을 지원</a>하는데 이를 통해 reference cycles(순환 참조)를 해결할 수 있다. gc모듈은 오로지 순환 참조를 탐지하고 해결하기 위해 존재한다. <a href=\"https://docs.python.org/3/library/gc.html\"><code>gc</code> 파이썬 공식문서</a>에서도 순환 참조를 만들지 않는다고 확신할 수 있으면 <code>gc.disable()</code>을 통해 garbage collector를 비활성화시켜도 된다고 언급하고 있다.</p>\n<blockquote>\n<p>Since the collector supplements the reference counting already used in Python, you can disable the collector if you are sure your program does not create reference cycles.</p>\n</blockquote>\n<h2>2. 가비지 컬렉션의 작동 방식</h2>\n<p>순환 참조 상태도 해결할 수 있는 cyclic garbage collection이 어떤 방식으로 동작하는지는 결국 <strong>어떤 기준으로 가비지 컬렉션이 발생</strong>하고 <strong>어떻게 순환 참조를 감지</strong>하는지에 관한 내용이다. 이에 대해 차근차근 알아보자.</p>\n<h3>2.1. 어떤 기준으로 가비지 컬렉션이 일어나는가</h3>\n<p>앞에서 제기했던 의문은 결국 발생 기준에 관한 의문이다. 가비지 컬렉터는 내부적으로 <code>generation</code>(세대)과 <code>threshold</code>(임계값)로 가비지 컬렉션 주기와 객체를 관리한다. 세대는 0세대, 1세대, 2세대로 구분되는데 최근에 생성된 객체는 0세대(young)에 들어가고 오래된 객체일수록 2세대(old)에 존재한다. 더불어 한 객체는 단 하나의 세대에만 속한다. 가비지 컬렉터는 0세대일수록 더 자주 가비지 컬렉션을 하도록 설계되었는데 이는 <a href=\"http://www.memorymanagement.org/glossary/g.html#term-generational-hypothesis\">generational hypothesis</a>에 근거한다.</p>\n<details>\n    <summary>generational hypothesis의 두 가지 가설</summary>\n<br>\n<ul>\n    <li>대부분의 객체는 금방 도달할 수 없는 상태(unreachable)가 된다.</li>\n    <li>오래된 객체(old)에서 젊은 객체(young)로의 참조는 아주 적게 존재한다.</li>\n</ul>\n<p>\n    <img src=\"https://plumbr.io/wp-content/uploads/2015/05/object-age-based-on-GC-generation-generational-hypothesis.png\" alt=\"\">\n    <br>\n    <sup>\n        <em>출처\n            <a href=\"https://plumbr.io/handbook/garbage-collection-in-java/generational-hypothesis\">plumbr.io</a>\n        </em>\n    </sup>\n</p>\n<ul>\n    <li>\n        <a href=\"http://d2.naver.com/helloworld/1329\">Reference: Naver D2 - Java Garbage Collection</a>\n    </li>\n</ul>\n<hr>\n</details>\n<p>주기는 threshold와 관련 있는데 <code>gc.get_threshold()</code>로 확인해 볼 수 있다.</p>\n<pre><code class=\"language-python\">>>> gc.get_threshold()\n(700, 10, 10)\n</code></pre>\n<p>각각 <code>threshold 0</code>, <code>threshold 1</code>, <code>threshold 2</code>를 의미하는데 n세대에 객체를 할당한 횟수가 <code>threshold n</code>을 초과하면 가비지 컬렉션이 수행되며 이 값은 변경될 수 있다.</p>\n<p>0세대의 경우 메모리에 객체가 할당된 횟수에서 해제된 횟수를 뺀 값, 즉 객체 수가 <code>threshold 0</code>을 초과하면 실행된다. 다만 그 이후 세대부터는 조금 다른데 0세대 가비지 컬렉션이 일어난 후 0세대 객체를 1세대로 이동시킨 후 카운터를 1 증가시킨다. 이 1세대 카운터가 <code>threshold 1</code>을 초과하면 그때 1세대 가비지 컬렉션이 일어난다. 비약시켜서 0세대 가비지 컬렉션이 객체 생성 700번만에 일어난다면 1세대는 7000번만에, 2세대는 7만번만에 일어난다는 뜻이다.</p>\n<p>이를 말로 풀어서 설명하려니 조금 복잡해졌지만 간단하게 말하면 메모리 할당시 <code>generation[0].count++</code>, 해제시 <code>generation[0].count--</code>가 발생하고, <code>generation[0].count > threshold[0]</code>이면 <code>genereation[0].count = 0</code>, <code>generation[1].count++</code>이 발생하고 <code>generation[1].count > 10</code>일 때 0세대, 1세대 count를 0으로 만들고 <code>generation[2].count++</code>을 한다는 뜻이다.</p>\n<p><a href=\"https://github.com/python/cpython/blob/master/Modules/gcmodule.c#L832-L836\">gcmodule.c 코드로 보기</a></p>\n<h3>2.2. 라이프 사이클</h3>\n<p>이렇듯 가비지 컬렉터는 세대와 임계값을 통해 가비지 컬렉션의 주기를 관리한다. 이제 가비지 컬렉터가 어떻게 순환 참조를 발견하는지 알아보기에 앞서 가비지 컬렉션의 실행 과정(라이프 사이클)을 간단하게 알아보자.</p>\n<p>새로운 객체가 만들어질때 파이썬은 객체를 메모리와 0세대에 할당한다. 만약 0세대의 객체 수가 <code>threshold 0</code>보다 크면 <code>collect_generations()</code>를 실행한다.</p>\n<details>\n    <summary>코드와 함께하는 더 자세한 설명</summary>\n<br>\n<p>새로운 객체가 만들어 질 때 파이썬은\n    <code class=\"highlighter-rouge\">_PyObject_GC_Alloc()</code>을 호출한다. 이 메서드는 객체를 메모리에 할당하고, 가비지 컬렉터의 0세대의 카운터를 증가시킨다. 그 다음 0세대의 객체 수가\n    <code class=\"highlighter-rouge\">threshold 0</code>보다 큰지,\n    <code class=\"highlighter-rouge\">gc.enabled</code>가 true인지,\n    <code class=\"highlighter-rouge\">threshold 0</code>이 0이 아닌지, 가비지 컬렉션 중이 아닌지 확인하고, 모든 조건을 만족하면\n    <code class=\"highlighter-rouge\">collect_generations()</code>를 실행한다.\n</p>\n<p>다음은\n    <code class=\"highlighter-rouge\">_PyObject_GC_Alloc()</code>을 간략화 한 소스며 메서드 전체 내용은\n    <a href=\"https://github.com/python/cpython/blob/master/Modules/gcmodule.c#L1681-L1710\">여기</a>에서 확인할 수 있다.\n</p>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nf\">_PyObject_GC_Alloc</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// ...\n</span>\n    <span class=\"n\">gc</span><span class=\"p\">.</span><span class=\"n\">generations</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">count</span><span class=\"o\">++</span><span class=\"p\">;</span> <span class=\"cm\">/* 0세대 카운터 증가 */</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">gc</span><span class=\"p\">.</span><span class=\"n\">generations</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">count</span> <span class=\"o\">&gt;</span> <span class=\"n\">gc</span><span class=\"p\">.</span><span class=\"n\">generations</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">threshold</span> <span class=\"o\">&amp;&amp;</span> <span class=\"cm\">/* 임계값을 초과하며 */</span>\n        <span class=\"n\">gc</span><span class=\"p\">.</span><span class=\"n\">enabled</span> <span class=\"o\">&amp;&amp;</span>  <span class=\"cm\">/* 사용가능하며 */</span>\n        <span class=\"n\">gc</span><span class=\"p\">.</span><span class=\"n\">generations</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">threshold</span> <span class=\"o\">&amp;&amp;</span>  <span class=\"cm\">/* 임계값이 0이 아니고 */</span>\n        <span class=\"o\">!</span><span class=\"n\">gc</span><span class=\"p\">.</span><span class=\"n\">collecting</span><span class=\"p\">)</span>  <span class=\"cm\">/* 컬렉션 중이 아니면 */</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">gc</span><span class=\"p\">.</span><span class=\"n\">collecting</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"n\">collect_generations</span><span class=\"p\">();</span>\n        <span class=\"n\">gc</span><span class=\"p\">.</span><span class=\"n\">collecting</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"c1\">// ...\n</span><span class=\"p\">}</span>\n</code></pre></div></div>\n<p>참고로\n    <code class=\"highlighter-rouge\">gc</code>를 끄고싶으면\n    <code class=\"highlighter-rouge\">gc.disable()</code>보단\n    <code class=\"highlighter-rouge\">gc.set_threshold(0)</code>이 더 확실하다.\n    <code class=\"highlighter-rouge\">disable()</code>의 경우 서드 파티 라이브러리에서\n    <code class=\"highlighter-rouge\">enable()</code>하는 경우가 있다고 한다.\n</p>\n<hr>\n</details>\n<p><code>collect_generations()</code> 메서드가 호출되면 모든 세대(기본적으로 3개의 세대)를 검사하는데 가장 오래된 세대(2세대)부터 역으로 확인한다. 해당 세대에 객체가 할당된 횟수가 각 세대에 대응되는 <code>threshold n</code>보다 크면 <code>collect()</code>를 호출해 가비지 컬렉션을 수행한다.</p>\n<details>\n    <summary>코드</summary>\n<br>\n<p>\n    <code class=\"highlighter-rouge\">collect()</code>가 호출될 때 해당 세대보다 어린 세대들은 모두 통합되어 가비지 컬렉션이 수행되기 때문에\n    <code class=\"highlighter-rouge\">break</code>를 통해 검사를 중단한다.\n</p>\n<p>다음은\n    <code class=\"highlighter-rouge\">collect_generations()</code>을 간략화 한 소스며 메서드 전체 내용은\n    <a href=\"https://github.com/python/cpython/blob/master/Modules/gcmodule.c#L1020-L1056\">여기</a>에서 확인할 수 있다.\n</p>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">static</span> <span class=\"n\">Py_ssize_t</span>\n<span class=\"nf\">collect_generations</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">NUM_GENERATIONS</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">--</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">gc</span><span class=\"p\">.</span><span class=\"n\">generations</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">count</span> <span class=\"o\">&gt;</span> <span class=\"n\">gc</span><span class=\"p\">.</span><span class=\"n\">generations</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">threshold</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">collect_with_callback</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span>\n            <span class=\"k\">break</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<p><span class=\"k\">static</span> <span class=\"n\">Py_ssize_t</span>\n<span class=\"nf\">collect_with_callback</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">generation</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n<span class=\"c1\">// ...\n</span>    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">collect</span><span class=\"p\">(</span><span class=\"n\">generation</span><span class=\"p\">,</span> <span class=\"o\">&#x26;</span><span class=\"n\">collected</span><span class=\"p\">,</span> <span class=\"o\">&#x26;</span><span class=\"n\">uncollectable</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n<span class=\"c1\">// ...\n</span><span class=\"p\">}</span>\n</code></pre></div></div></p>\n<hr>\n</details>\n<p><code>collect()</code> 메서드는 <strong>순환 참조 탐지 알고리즘</strong>을 수행하고 특정 세대에서 도달할 수 있는 객체(reachable)와 도달할 수 없는 객체(unreachable)를 구분하고 도달할 수 없는 객체 집합을 찾는다. 도달할 수 있는 객체 집합은 다음 상위 세대로 합쳐지고(0세대에서 수행되었으면 1세대로 이동), 도달할 수 없는 객체 집합은 콜백을 수행한 후 메모리에서 해제된다.</p>\n<p>이제 정말 <strong>순환 참조 탐지 알고리즘</strong>을 알아볼 때가 됐다.</p>\n<h3>2.3. 어떻게 순환 참조를 감지하는가</h3>\n<p>먼저 순환 참조는 컨테이너 객체(e.g. <code>tuple</code>, <code>list</code>, <code>set</code>, <code>dict</code>, <code>class</code>)에 의해서만 발생할 수 있음을 알아야 한다. 컨테이너 객체는 다른 객체에 대한 참조를 보유할 수 있다. 그러므로 정수, 문자열은 무시한 채 관심사를 컨테이너 객체에만 집중할 수 있다.</p>\n<p>순환 참조를 해결하기 위한 아이디어로 모든 컨테이너 객체를 추적한다. 여러 방법이 있겠지만 객체 내부의 링크 필드에 더블 링크드 리스트를 사용하는 방법이 가장 좋다. 이렇게 하면 추가적인 메모리 할당 없이도 <strong>컨테이너 객체 집합</strong>에서 객체를 빠르게 추가하고 제거할 수 있다. 컨테이너 객체가 생성될 때 이 집합에 추가되고 제거될 때 집합에서 삭제된다.</p>\n<details>\n    <summary>\n        <code class=\"highlighter-rouge\">PyGC_Head</code>에 선언된 더블 링크드 리스트\n    </summary>\n<br>\n<p>더블 링크드 리스트는 다음과 같이 선언되어 있으며\n    <a href=\"https://github.com/python/cpython/blob/master/Include/objimpl.h#L250-L259\">objimpl.h 코드</a>에서 확인해볼 수 있다.\n</p>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"nf\">#ifndef</span> <span class=\"p\">Py_LIMITED_API\n</span><span class=\"k\">typedef</span> <span class=\"k\">union</span> <span class=\"n\">_gc_head</span> <span class=\"p\">{</span>\n    <span class=\"k\">struct</span> <span class=\"p\">{</span>\n        <span class=\"k\">union</span> <span class=\"n\">_gc_head</span> <span class=\"o\">*</span><span class=\"n\">gc_next</span><span class=\"p\">;</span>\n        <span class=\"k\">union</span> <span class=\"n\">_gc_head</span> <span class=\"o\">*</span><span class=\"n\">gc_prev</span><span class=\"p\">;</span>\n        <span class=\"n\">Py_ssize_t</span> <span class=\"n\">gc_refs</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span> <span class=\"n\">gc</span><span class=\"p\">;</span>\n    <span class=\"kt\">double</span> <span class=\"n\">dummy</span><span class=\"p\">;</span>  <span class=\"cm\">/* force worst-case alignment */</span>\n<span class=\"p\">}</span> <span class=\"n\">PyGC_Head</span><span class=\"p\">;</span>\n</code></pre></div></div>\n<hr>\n</details>\n<p>이제 모든 컨테이너 객체에 접근할 수 있으니 순환 참조를 찾을 수 있어야 한다. 순환 참조를 찾는 과정은 다음과 같다.</p>\n<ol>\n<li>객체에 <code>gc_refs</code> 필드를 레퍼런스 카운트와 같게 설정한다.</li>\n<li>각 객체에서 참조하고 있는 다른 컨테이너 객체를 찾고, 참조되는 컨테이너의 <code>gc_refs</code>를 감소시킨다.</li>\n<li><code>gc_refs</code>가 0이면 그 객체는 컨테이너 집합 내부에서 자기들끼리 참조하고 있다는 뜻이다.</li>\n<li>그 객체를 unreachable 하다고 표시한 뒤 메모리에서 해제한다.</li>\n</ol>\n<p>이제 우리는 가비지 컬렉터가 어떻게 순환 참조 객체를 탐지하고 메모리에서 해제하는지 알았다.</p>\n<h2>3. 예제</h2>\n<blockquote>\n<p>아래 예제는 보기 쉽게 가공한 예제이며 실제 <code>collect()</code>의 동작과는 차이가 있다. 정확한 작동 방식은 아래에서 다시 서술한다. 혹은 <a href=\"https://github.com/python/cpython/blob/master/Modules/gcmodule.c#L797-L981\"><code>collect()</code> 코드</a>를 참고하자.</p>\n</blockquote>\n<p>아래의 예제를 통해 가비지 컬렉터가 어떤 방법으로 순환 참조 객체인 <code>Foo(0)</code>과 <code>Foo(1)</code>을 해제하는지 알아보겠다.</p>\n<pre><code class=\"language-python\">a = [1]\n# Set: a:[1]\nb = ['a']\n# Set: a:[1] &#x3C;-> b:['a']\nc = [a, b]\n# Set: a:[1] &#x3C;-> b:['a'] &#x3C;-> c:[a, b]\nd = c\n# Set: a:[1] &#x3C;-> b:['a'] &#x3C;-> c,d:[a, b]\n# 컨테이너 객체가 생성되지 않았기에 레퍼런스 카운트만 늘어난다.\ne = Foo(0)\n# Set: a:[1] &#x3C;-> b:['a'] &#x3C;-> c,d:[a, b] &#x3C;-> e:Foo(0)\nf = Foo(1)\n# Set: a:[1] &#x3C;-> b:['a'] &#x3C;-> c,d:[a, b] &#x3C;-> e:Foo(0) &#x3C;-> f:Foo(1)\ne.x = f\n# Set: a:[1] &#x3C;-> b:['a'] &#x3C;-> c,d:[a, b] &#x3C;-> e:Foo(0) &#x3C;-> f,Foo(0).x:Foo(1)\nf.x = e\n# Set: a:[1] &#x3C;-> b:['a'] &#x3C;-> c,d:[a, b] &#x3C;-> e,Foo(1).x:Foo(0) &#x3C;-> f,Foo(0).x:Foo(1)\ndel e\n# Set: a:[1] &#x3C;-> b:['a'] &#x3C;-> c,d:[a, b] &#x3C;-> Foo(1).x:Foo(0) &#x3C;-> f,Foo(0).x:Foo(1)\ndel f\n# Set: a:[1] &#x3C;-> b:['a'] &#x3C;-> c,d:[a, b] &#x3C;-> Foo(1).x:Foo(0) &#x3C;-> Foo(0).x:Foo(1)\n</code></pre>\n<p>위 상황에서 각 컨테이너 객체의 레퍼런스 카운트는 다음과 같다.</p>\n<pre><code class=\"language-py\"># ref count\n[1]     &#x3C;- a,c      = 2\n['a']   &#x3C;- b,c      = 2\n[a, b]  &#x3C;- c,d      = 2\nFoo(0)  &#x3C;- Foo(1).x = 1\nFoo(1)  &#x3C;- Foo(0).x = 1\n</code></pre>\n<p>1번 과정에서 각 컨테이너 객체의 <code>gc_refs</code>가 설정된다.</p>\n<pre><code class=\"language-py\"># gc_refs\n[1]    = 2\n['a']  = 2\n[a, b] = 2\nFoo(0) = 1\nFoo(1) = 1\n</code></pre>\n<p>2번 과정에서 컨테이너 집합을 순회하며 <code>gc_refs</code>을 감소시킨다.</p>\n<pre><code class=\"language-py\">[1]     = 1  # [a, b]에 의해 참조당하므로 1 감소\n['a']   = 1  # [a, b]에 의해 참조당하므로 1 감소\n[a, b]  = 2  # 참조당하지 않으므로 그대로\nFoo(0)  = 0  # Foo(1)에 의해 참조당하므로 1 감소\nFoo(1)  = 0  # Foo(0)에 의해 참조당하므로 1 감소\n</code></pre>\n<p>3번 과정을 통해 <code>gc_refs</code>가 0인 순환 참조 객체를 발견했다. 이제 이 객체를 unreachable 집합에 옮겨주자.</p>\n<pre><code class=\"language-py\"> unreachable |  reachable\n             |    [1] = 1\n Foo(0) = 0  |  ['a'] = 1\n Foo(1) = 0  | [a, b] = 2\n</code></pre>\n<p>이제 <code>Foo(0)</code>와 <code>Foo(1)</code>을 메모리에서 해제하면 가비지 컬렉션 과정이 끝난다.</p>\n<h2>4. 더 정확하고 자세한 설명</h2>\n<p><code>collect()</code> 메서드는 현재 세대와 어린 세대를 합쳐 순환 참조를 검사한다. 이 합쳐진 세대를 <code>young</code>으로 이름 붙이고 다음의 과정을 거치며 최종적으로 도달할 수 없는 객체가 모인 unreachable 리스트를 메모리에서 해제하고 young에 남아있는 객체를 다음 세대에 할당한다.</p>\n<pre><code class=\"language-c\">update_refs(young)\nsubtract_refs(young)\ngc_init_list(&#x26;unreachable)\nmove_unreachable(young, &#x26;unreachable)\n</code></pre>\n<p><code>update_refs()</code>는 모든 객체의 레퍼런스 카운트 사본을 만든다. 이는 가비지 컬렉터가 실제 레퍼런스 카운트를 건드리지 않게 하기 위함이다.</p>\n<p><code>subtract_refs()</code>는 각 객체 i에 대해 i에 의해 참조되는 객체 j의 <code>gc_refs</code>를 감소시킨다. 이 과정이 끝나면 (young 세대에 남아있는 객체의 레퍼런스 카운트) - (남아있는 <code>gc_refs</code>) 값이 old 세대에서 young 세대를 참조하는 수와 같다.</p>\n<p><code>move_unreachable()</code> 메서드는 young 세대를 스캔하며 <code>gc_refs</code>가 0인 객체를 <code>unreachable</code> 리스트로 이동시키고 <code>GC_TENTATIVELY_UNREACHABLE</code>로 설정한다. 왜 완전히 <code>unreachable</code>이 아닌 임시로(Tentatively) 설정하냐면 나중에 스캔 될 객체로부터 도달할 수도 있기 때문이다.</p>\n<details>\n    <summary>예제 보기</summary>\n<br>\n<div class=\"language-py highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">Foo</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">),</span> <span class=\"n\">Foo</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">b</span>\n<span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">a</span>\n<span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">b</span>\n<span class=\"k\">del</span> <span class=\"n\">a</span>\n<span class=\"k\">del</span> <span class=\"n\">b</span>\n<p><span class=\"c\"># 위 상황을 요약하면 다음과 같다.</span>\n<span class=\"n\">Foo</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">Foo</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">Foo</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">Foo</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">Foo</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</code></pre></div></div></p>\n<p>이때 상황은 다음과 같은데\n    <code class=\"highlighter-rouge\">Foo(0)</code>의\n    <code class=\"highlighter-rouge\">gc_refs</code>가 0이어도 뒤에 나올\n    <code class=\"highlighter-rouge\">Foo(1)</code>을 통해 도달할 수 있다.\n</p>\n<table>\n  <thead>\n    <tr>\n      <th style=\"text-align: center\">young</th>\n      <th style=\"text-align: center\">ref count</th>\n      <th style=\"text-align: center\">gc_refs</th>\n      <th style=\"text-align: center\">reachable</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style=\"text-align: center\"><code class=\"highlighter-rouge\">Foo(0)</code></td>\n      <td style=\"text-align: center\">1</td>\n      <td style=\"text-align: center\">0</td>\n      <td style=\"text-align: center\"><code class=\"highlighter-rouge\">c.x</code></td>\n    </tr>\n    <tr>\n      <td style=\"text-align: center\"><code class=\"highlighter-rouge\">Foo(1)</code></td>\n      <td style=\"text-align: center\">2</td>\n      <td style=\"text-align: center\">1</td>\n      <td style=\"text-align: center\"><code class=\"highlighter-rouge\">c</code></td>\n    </tr>\n  </tbody>\n</table>\n<hr>\n</details>\n<p>0이 아닌 객체는 <code>GC_REACHABLE</code>로 설정하고 그 객체가 참조하고 있는 객체 또한 찾아가(traverse) <code>GC_REACHABLE</code>로 설정한다. 만약 그 객체가 <code>unreachable</code> 리스트에 있던 객체라면 <code>young</code> 리스트의 끝으로 보낸다. 굳이 <code>young</code>의 끝으로 보내는 이유는 그 객체 또한 다른 <code>gc_refs</code>가 0인 객체를 참조하고 있을 수 있기 때문이다.</p>\n<details>\n    <summary>예제 보기</summary>\n<br>\n<div class=\"language-py highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">Foo</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">),</span> <span class=\"n\">Foo</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">b</span>\n<span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">a</span>\n<span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">b</span>\n<span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"n\">Foo</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">d</span><span class=\"o\">.</span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">d</span>\n<span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">d</span>\n<span class=\"k\">del</span> <span class=\"n\">d</span>\n<span class=\"k\">del</span> <span class=\"n\">a</span>\n<span class=\"k\">del</span> <span class=\"n\">b</span>\n<p><span class=\"c\"># 위 상황을 요약하면 다음과 같다.</span>\n<span class=\"n\">Foo</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">Foo</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">Foo</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">Foo</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">Foo</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">Foo</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">Foo</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n</code></pre></div></div></p>\n<table>\n  <thead>\n    <tr>\n      <th style=\"text-align: center\">young</th>\n      <th style=\"text-align: center\">ref count</th>\n      <th style=\"text-align: center\">gc_refs</th>\n      <th style=\"text-align: center\">reachable</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style=\"text-align: center\"><code class=\"highlighter-rouge\">Foo(0)</code></td>\n      <td style=\"text-align: center\">1</td>\n      <td style=\"text-align: center\">0</td>\n      <td style=\"text-align: center\"><code class=\"highlighter-rouge\">c.x</code></td>\n    </tr>\n    <tr>\n      <td style=\"text-align: center\"><code class=\"highlighter-rouge\">Foo(1)</code></td>\n      <td style=\"text-align: center\">2</td>\n      <td style=\"text-align: center\">1</td>\n      <td style=\"text-align: center\"><code class=\"highlighter-rouge\">c</code></td>\n    </tr>\n    <tr>\n      <td style=\"text-align: center\"><code class=\"highlighter-rouge\">Foo(2)</code></td>\n      <td style=\"text-align: center\">1</td>\n      <td style=\"text-align: center\">0</td>\n      <td style=\"text-align: center\"><code class=\"highlighter-rouge\">c.x.y</code></td>\n    </tr>\n  </tbody>\n</table>\n<p>이 상황에서\n    <code class=\"highlighter-rouge\">Foo(0)</code>은\n    <code class=\"highlighter-rouge\">unreachable</code> 리스트에 있다가\n    <code class=\"highlighter-rouge\">Foo(1)</code>을 조사하며 다시\n    <code class=\"highlighter-rouge\">young</code> 리스트의 맨 뒤로 돌아왔고,\n    <code class=\"highlighter-rouge\">Foo(2)</code>도\n    <code class=\"highlighter-rouge\">unreachable</code> 리스트에 갔지만, 곧\n    <code class=\"highlighter-rouge\">Foo(0)</code>에 의해 참조될 수 있음을 알고 다시\n    <code class=\"highlighter-rouge\">young</code> 리스트로 돌아온다.\n</p>\n<hr>\n</details>\n<p><code>young</code> 리스트의 전체 스캔이 끝나면 이제 <code>unreachable</code> 리스트에 있는 객체는 <strong>정말 도달할 수 없다</strong>. 이제 이 객체들을 메모리에서 해제되고 <code>young</code> 리스트의 객체들은 상위 세대로 합쳐진다.</p>\n<h2>5. Reference</h2>\n<ul>\n<li><a href=\"https://b.luavis.kr/python/dismissing-python-garbage-collection-at-instagram\">Instagram이 gc를 없앤 이유</a></li>\n<li><a href=\"http://weicomes.tistory.com/277\">파이썬 Garbage Collection</a></li>\n<li><a href=\"https://www.kylev.com/2009/11/03/finding-my-first-python-reference-cycle/\">Finding reference cycle</a></li>\n<li><a href=\"http://d2.naver.com/helloworld/1329\">Naver D2 - Java Garbage Collection</a></li>\n<li><a href=\"https://docs.python.org/3/library/gc.html#gc.set_threshold\">gc의 threshold</a></li>\n</ul>\n<p>아래의 링크는 특히 큰 도움이 되었다.</p>\n<ul>\n<li><a href=\"http://www.arctrix.com/nas/python/gc/\">Garbage Collection for Python</a></li>\n<li><a href=\"https://www.quora.com/How-does-garbage-collection-in-Python-work-What-are-the-pros-and-cons\">How does garbage collection in Python work</a></li>\n<li><a href=\"https://github.com/python/cpython/blob/master/Modules/gcmodule.c\">gcmodule.c</a></li>\n</ul>\n<p>잘못된 정보, 오타 혹은 보완할 점이 있으면 <a href=\"https://twitter.com/res_tin\">트위터</a>, <a href=\"mailto:wintermy201@gmail.com\">메일</a> 등으로 알려주시면 감사하겠습니다.</p>","frontmatter":{"title":"Python GC가 작동하는 원리","image":null},"excerpt":"보통 파이썬은 레퍼런스 카운팅 방식으로 가비지 컬렉션을 수행해 메모리를 관리하고, 레퍼런스 카운팅을 사용했을 때 발생할 수 있는 순환 참조 상황을 별도의 가비지 컬렉터로 해결한다고 알고 있다. 이 글에서는 그 가비지 컬렉터가 어떤 방식으로 작동하는지…"}},"pageContext":{"slug":"python-gc","date":"2018-02-18","lastmod":"2018-02-18"}},"staticQueryHashes":["269600272","3159585216"],"slicesMap":{}}