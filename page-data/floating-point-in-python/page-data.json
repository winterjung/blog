{"componentChunkName":"component---src-templates-post-jsx","path":"/floating-point-in-python/","result":{"data":{"markdownRemark":{"html":"<p>실수형 값을 다룰 때 흔히 마주칠 수 있는 부동소수점 오차 문제를 파이썬에서 어떻게 해결할 수 있는지 알아보았다.</p>\n<blockquote>\n<p>이 글은 <a href=\"https://github.com/JungWinter/JungWinter.github.io/blob/496e1b8e4563cd32c291cde1f1db62684d6db7dd/_posts/2017-1-12-Floating-Point.md\">2017년에 작성했던 글</a>을 다듬고 내용을 추가해 다시 작성한 글입니다. 본래 글은 이 문서로 리다이렉트됩니다.</p>\n</blockquote>\n<h2>부동소수점의 문제</h2>\n<p><code>float</code> 자료형을 쓸 때는 항상 주의해야 한다. 특히 <code>if</code> 문으로 값을 확인할 때 이를 간과하면 아래처럼 찾기 힘든 버그가 발생한다.</p>\n<pre><code class=\"language-python\">>>> 0.1 * 3 == 0.3\nFalse\n>>> 1.2 - 0.1 == 1.1\nFalse\n>>> 0.1 * 0.1 == 0.01\nFalse\n</code></pre>\n<p>그동안 위와 같은 일이 발생해도 그저 '부동소수점 때문에 그래' 정도로만 알고 있었는데 그 이유를 좀 더 자세히 알아보고 파이썬에서 어떻게 해결할 수 있는지 알아보았다.</p>\n<blockquote>\n<p><code>부동소수점</code>에 대한 설명은 다른 자료들에서 잘 다루고 있으니 여기선 <a href=\"https://ko.wikipedia.org/wiki/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90\">위키피디아 문서</a>로 대체한다.</p>\n</blockquote>\n<h2>부동소수점의 표현 방식</h2>\n<p>컴퓨터에서 부동소수점 숫자들은 2진 분수로 표현되기에 꽤 많은 값은 정확히 표현될 수 없다. 그렇기에 사람이 이해하기 쉽게 입력하는 10진 부동소수점 숫자는 2진 부동소수점 숫자로 근사 된다. 예를 들어 10진수 0.1은 2진 분수로 정확하게 표현될 수 없고 <code>0.0001100110011001100110...</code>처럼 무한히 반복되기에 특정 비트에서 멈추고 근사값을 얻는다. 0.1의 경우는 <code>3602879701896397 / 2 ** 55</code>이며 0.1에 가깝지만, 정확히 동일하지는 않다.</p>\n<pre><code class=\"language-python\">>>> decimal.Decimal(3602879701896397 / 2 ** 55)\nDecimal('0.1000000000000000055511151231257827021181583404541015625')\n>>> decimal.Decimal(0.1)\nDecimal('0.1000000000000000055511151231257827021181583404541015625')\n</code></pre>\n<p>다만 이를 곧이곧대로 길게 표현한다면 꽤 많은 상황에서 성가실 것이기에 파이썬에선 이런 부동소수점 값을 표현할 때 정확히 표현하지 않고 10진수 근삿값만을 표시한다.</p>\n<pre><code class=\"language-python\">>>> 0.1\n0.1000000000000000055511151231257827021181583404541015625\n</code></pre>\n<p>0.1에 대해 실제 십진수 값을 출력한다면 위와 같겠지만 파이썬에선 반올림된 값을 표시한다.</p>\n<pre><code class=\"language-python\">>>> 1 / 10\n0.1\n</code></pre>\n<p>이런 부동소수점의 한계는 파이썬뿐만 아니라 부동소수점을 지원하는 거의 모든 언어에서 찾아볼 수 있다.</p>\n<blockquote>\n<p>각 언어의 부동소수점 처리 방식을 볼 수 있는 <a href=\"https://0.30000000000000004.com/\">0.30000000000000004.com</a>이란 사이트도 있다.</p>\n</blockquote>\n<h2>해결책</h2>\n<p><code>decimal.Decimal</code>, <code>math.fsum()</code>, <code>round()</code>, <code>float.as_integer_ratio()</code>, <code>math.is_close()</code> 함수 혹은 다른 방법을 통해서 실수를 방지할 수 있다. 이 중 가장 추천하는 방법은 <code>decimal</code> 표준 라이브러리를 사용한 방법이고 그 외에도 존재하는 관련 함수들을 소개한다.</p>\n<h3><code>decimal.Decimal</code></h3>\n<pre><code class=\"language-py\">>>> import decimal\n>>> decimal.Decimal('0.1') * 3 == decimal.Decimal('0.3')\nTrue\n>>> decimal.Decimal('0.3') + 2\nDecimal('2.3')\n</code></pre>\n<p><a href=\"https://docs.python.org/3/library/decimal.html\"><code>decimal</code> 모듈</a>을 사용하면 위 문제를 가장 깔끔하게 해결할 수 있다. 파이썬 문서에서도 언급하듯 빠르고 정확한 부동 소수 산술을 지원하며 <code>float</code> 자료형을 그대로 사용할 때 보다 여러 이점이 있다고 말한다.</p>\n<p>다만 아래와 같이 사용한다면 여전히 문제가 발생하고 이를 처리하는 건 <code>decimal</code> 모듈의 책임이 아니기에 사용에 주의해야 한다.</p>\n<pre><code class=\"language-py\">>>> decimal.Decimal(0.1 * 3)\nDecimal('0.3000000000000000444089209850062616169452667236328125')\n</code></pre>\n<h3><code>math.fsum()</code></h3>\n<p><a href=\"https://docs.python.org/3/library/math.html#math.fsum\"><code>math</code> 모듈의 <code>fsum()</code> 함수</a>를 이용해 두 개 이상의 부동소수점 합계와 관련된 반올림 오류 누적을 제거하여 정밀도 손실을 방지할 수 있다.</p>\n<pre><code class=\"language-python\">>>> sum([.1] * 10)\n0.9999999999999999\n>>> math.fsum([.1] * 10)\n1.0\n</code></pre>\n<p>다만 <code>fsum()</code>은 중간중간 누적된 오류를 해결하기 위함이지 정확한 부동소수점 연산을 위한 게 아니다 보니 유명한 <code>0.1 + 0.2</code>처럼 항상 원하는 결과를 기대할 수는 없다.</p>\n<pre><code class=\"language-python\">>>> math.fsum([.1, .2])\n0.30000000000000004\n</code></pre>\n<ul>\n<li><a href=\"http://stackoverflow.com/questions/34650535/python2-math-fsum-not-accurate\">스택오버플로우 : 왜 fsum은 부정확한가 </a></li>\n</ul>\n<h3><code>round()</code></h3>\n<p>빌트인 함수로 있는 <code>round()</code>로 반올림해 해결하는 방법도 있다.</p>\n<pre><code class=\"language-python\">>>> round(0.1 + 0.1 + 0.1, 10) == round(0.3, 10)\nTrue\n>>> 0.1 + 0.1 + 0.1 == 0.3\nFalse\n# 0.1 + 0.1 + 0.1은 0.3과 다르다.\n>>> decimal.Decimal(0.1 + 0.1 + 0.1)\nDecimal('0.3000000000000000444089209850062616169452667236328125')\n>>> decimal.Decimal(0.3)\nDecimal('0.299999999999999988897769753748434595763683319091796875')\n</code></pre>\n<p>당연하게도 사전 <code>round()</code>는 도움이 되지 않는데 <code>0.1</code>은 <code>round(0.1, 1)</code> 등과 같기에 각각을 반올림하고 더해주는건 아무 의미 없다.</p>\n<pre><code class=\"language-python\">>>> round(0.1, 1) + round(0.1, 1) + round(0.1, 1) == round(0.3, 1)\nFalse\n</code></pre>\n<h4>반올림 모드</h4>\n<p>우리는 반올림을 할 때 5부터는 올림으로 그 밑은 내림으로 한다고 알고 있지만 파이썬에선 여러 가지 반올림 모드 옵션을 제공한다. 기본적으로 설정된 모드 상으론 값에 따라 어떤건 0.5더라도 내림이 되기도 하고 올림이 되기도 한다.</p>\n<pre><code class=\"language-python\">>>> round(0.125, 2)\n0.12\n>>> round(0.135, 2)\n0.14\n</code></pre>\n<p>이 반올림 모드엔 여러 가지가 있는데 <a href=\"https://docs.python.org/ko/3/library/decimal.html#decimal.DefaultContext\">기본적으로 <code>ROUND_HALF_EVEN</code>이라는 모드로 지정</a>되어 있고 이는 짝수랑 가까워지는 방향으로 동작한다. 현재 적용된 반올림 방식이 무엇인지는 <code>deciaml.getcontext()</code>로 확인해 볼 수 있다.</p>\n<pre><code class=\"language-python\">>>> import decimal\n>>> decimal.getcontext()\nContext(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, ...)\n</code></pre>\n<ul>\n<li><code>ROUND_CEILING</code></li>\n<li><code>ROUND_DOWN</code></li>\n<li><code>ROUND_FLOOR</code></li>\n<li><code>ROUND_HALF_DOWN</code></li>\n<li><code>ROUND_HALF_UP</code></li>\n<li><code>ROUND_UP</code></li>\n<li><code>ROUND_05UP</code></li>\n</ul>\n<p>위와 같이 <a href=\"https://docs.python.org/3/library/decimal.html#rounding-modes\">8가지 방식</a>이 존재하며 런타임에 이를 아래처럼 변경할 수 있다.</p>\n<pre><code class=\"language-python\">>>> ctx = decimal.getcontext()\n>>> ctx.rounding = decimal.ROUND_UP  # 혹은 'ROUND_UP' 문자열도 사용 가능\n</code></pre>\n<h3><code>float.as_integer_ratio()</code></h3>\n<p>파이썬 <code>float</code> 자료형에는 <code>as_integer_ratio()</code> 함수가 내장되어 있다.</p>\n<pre><code class=\"language-python\">>>> x = 3.141592\n>>> x.as_integer_ratio()\n(3537118140137533, 1125899906842624)\n>>> x == 3537118140137533 / 1125899906842624\nTrue\n</code></pre>\n<p>연산의 오차 보정용이라기 보다는 원래 값을 손실 없이 다시 만드는 데 유용하다.</p>\n<h3><code>math.is_close()</code></h3>\n<p>파이썬 3.5에서 새로 추가된 <code>math</code> 모듈의 함수다. <code>isclose(a, b, rel_tol=1e-9, abs_tol=0.0)</code>같은 형태이며 <code>a</code>와 <code>b</code>는 비교할 값들, <code>rel_tol</code>은 relative tolerance, <code>abs_tol</code>은 absolute tolerance다. <code>decimal</code>을 사용할 만큼 엄격한 상황이 아니라면 위에 나온 방법들보다 제일 간단하고 직관적이다.</p>\n<p>다만 파이썬 3.5 이상부터 내장되어 있으며 그보다 하위 버전에서는 직접 <code>is_close()</code> 함수를 만들어 사용해야 한다.</p>\n<pre><code class=\"language-python\"># 간단한 버전\ndef is_close(a, b, rel_tol=1e-09, abs_tol=0.0):\n    return abs(a-b) &#x3C;= max(rel_tol * max(abs(a), abs(b)), abs_tol)\n</code></pre>\n<ul>\n<li><a href=\"https://docs.python.org/3/library/math.html#math.isclose\"><code>math.is_close</code> 문서</a></li>\n<li><a href=\"https://www.python.org/dev/peps/pep-0485/\">PEP 485 - A Function for testing approximate equality</a></li>\n<li><a href=\"https://github.com/PythonCHB/close_pep/blob/master/is_close.py\"><code>math.is_close()</code>의 원형</a></li>\n</ul>\n<h3>기타</h3>\n<p>가장 쉽고 널리 사용되는 방법으로는 아마 <code>abs(a - b) &#x3C;= 1e-9</code> 정도가 아닐까 싶다.</p>\n<h2>정리</h2>\n<p><code>float</code> 자료형을 다룰 땐 항상 부동소수점 오차를 의식해야 한다. 위에서 나온 해결책 말고도 다양한 해결책이 있을 수 있겠지만 일단 회계나 금융의 엄격함이 요구된다면 <code>decimal</code> 모듈을 그렇지 않다면 마지막의 짧은 snippet이나 <code>math.is_close()</code>, <code>round()</code> 정도만 사용해도 크게 문제는 없으리라 생각한다.</p>\n<h2>참고</h2>\n<ul>\n<li><a href=\"https://docs.python.org/3/tutorial/floatingpoint.html\">python3 document - Floating Point Arithmetic: Issues and Limitations</a></li>\n<li><a href=\"https://app.box.com/s/vlij64akloz25k0fmk24o1fqxdndg8ie\">모든 컴퓨터 과학자가 알아야 할 부동 소수점의 모든것</a></li>\n<li><a href=\"http://stackoverflow.com/questions/5595425/what-is-the-best-way-to-compare-floats-for-almost-equality-in-python\">stackoverflow - What is the best way to compare floats for almost-equality in Python?</a></li>\n<li><a href=\"https://blog.udemy.com/python-round\">udemy blog - Python Round: Problems and Solutions</a></li>\n</ul>","frontmatter":{"title":"파이썬에서 부동소수점 오차 해결하기","image":null},"excerpt":"실수형 값을 다룰 때 흔히 마주칠 수 있는 부동소수점 오차 문제를 파이썬에서 어떻게 해결할 수 있는지 알아보았다. 이 글은 2017년에 작성했던 글을 다듬고 내용을 추가해 다시 작성한 글입니다. 본래 글은 이 문서로 리다이렉트됩니다. 부동소수점의 문…"}},"pageContext":{"slug":"floating-point-in-python","date":"2020-01-06","lastmod":"2020-01-06"}},"staticQueryHashes":["269600272","3159585216"],"slicesMap":{}}