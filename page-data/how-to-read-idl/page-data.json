{"componentChunkName":"component---src-templates-post-jsx","path":"/how-to-read-idl/","result":{"data":{"markdownRemark":{"html":"<p><img src=\"/images/idl.jpg\" alt=\"idl header image\"></p>\n<p>클라이언트와 서버간 api 명세를 <a href=\"https://developers.google.com/protocol-buffers\">protocol buffers</a>(이하 protobuf)로 idl<sub>Interface Description Language</sub> 삼아 개발할 때, 이 idl을 어떻게 읽어야 하는지 간단하게 알아보자.</p>\n<blockquote>\n<p>서버는 grpc를 지원하지만, 클라이언트가 json api 통신을 한다는 가정하에 <a href=\"https://github.com/grpc-ecosystem/grpc-gateway\">grpc-gateway</a>를 사용한다.</p>\n</blockquote>\n<h2>user 서비스를 예로</h2>\n<p>사용자 생성, 조회, 수정하는 간단한 유저 관리 서비스가 있다고 할 때 아래처럼 protobuf를 source of truth삼아 api 명세를 소통하려 한다.\n아래 같은 protobuf 파일은 해당 유저 서비스 레포에 존재하거나 조직의 공통 protobuf 관리 레포에 있거나 할 텐데 그래서 어느 endpoint에 어떤 요청을 보내야 하는지 헷갈릴 수 있다.</p>\n<p>파트를 나눠 어떤 요청 응답이 오가는지 보기에 앞서 서비스에 어떤 api들이 있는지 읽어보자.</p>\n<pre><code class=\"language-protobuf\">syntax = \"proto3\";\n\npackage user;\n\nimport \"google/api/annotations.proto\";\nimport \"google/protobuf/field_mask.proto\";\nimport \"google/protobuf/wrappers.proto\";\n\nservice User {\n  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse) {\n    option (google.api.http) = {\n      post: \"/v1/users\"\n      body: \"*\"\n    };\n  }\n  rpc GetUser(GetUserRequest) returns (GetUserResponse) {\n    option (google.api.http) = {\n      get: \"/v1/users/{user_id}\"\n    };\n  }\n  rpc UpdateUser(UpdateUserRequest) returns (UpdateUserResponse) {\n    option (google.api.http) = {\n      patch: \"/v1/users/{user_id}\"\n      body: \"update_spec\"\n    };\n  }\n}\n</code></pre>\n<h3>읽어보기</h3>\n<h4>meta 정보</h4>\n<pre><code class=\"language-protobuf\">syntax = \"proto3\";\n\npackage user;\n\nimport \"google/api/annotations.proto\";\nimport \"google/protobuf/field_mask.proto\";\nimport \"google/protobuf/wrappers.proto\";\n</code></pre>\n<p>크게 중요하진 않다. 주로 이 protobuf를 가지고 python, golang, java, swagger 등 다양한 output으로 generate 할 때 필요한 정보다.</p>\n<h4>서비스와 rpc</h4>\n<pre><code class=\"language-protobuf\">service User {\n  rpc CreateUser;\n  rpc GetUser;\n  rpc UpdateUser;\n}\n</code></pre>\n<p>예제로 나온 유저 관리 서비스처럼 특정 서버는 여러 api를 가진다.\n여기선 <code>User</code> 서비스에 사용자 생성, 조회, 업데이트 api가 있음을 알려준다. rpc 하나하나가 api에 대응된다.</p>\n<h4><code>rpc Xxx(Yyy) returns (Zzz)</code></h4>\n<pre><code>rpc CreateUser(CreateUserRequest) returns (CreateUserResponse) {\n</code></pre>\n<p>rpc의 형태는 <code>rpc Xxx(Yyy) returns (Zzz)</code> 처럼 생겼는데 마치 우리가 함수를 만들어 쓰듯 \"Xxx rpc는 Yyy를 input으로 받고 Zzz를 output으로 준다\"는 의미다.\n위 예시 rpc는 <code>CreateUser</code>라는 사용자 생성을 위한 rpc고 <code>CreateUserRequest</code>를 input으로 받아 <code>CreateUserResponse</code>를 반환하는 api라고 볼 수 있다.\n이 때 <code>CreateUserRequest</code>, <code>CreateUserResponse</code> message는 <code>{...}</code>처럼 json body라고 생각할 수 있다.</p>\n<blockquote>\n<p>그래서 이 rpc를 어떤 endpoint로 호출해야 하는지, 실제로 주고받는 body 내용은 뭔지는 후술한다.</p>\n</blockquote>\n<figure style=\"text-align: center;\">\n  <pre>\n  ┌──────────────────┐                          ┌──────────────────┐\n  │CreateUserRequest │   ┌──────────────────┐   │CreateUserResponse│\n  │                  │   │                  │   │                  │\n  │{                 │──▶│  CreateUser rpc  │──▶│{                 │\n  │  // fields       │   │                  │   │  // fields       │\n  │}                 │   └──────────────────┘   │}                 │\n  └──────────────────┘                          └──────────────────┘\n  </pre>\n  <figcaption>\n    rpc 호출 구조\n  </figcaption>\n</figure>\n<h4>rpc option</h4>\n<pre>\n  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse) {\n    option (google.api.http) = {\n      <b>post: \"/v1/users\"</b>\n      body: \"*\"\n    };\n  }\n  rpc GetUser(GetUserRequest) returns (GetUserResponse) {\n    option (google.api.http) = {\n      <b>get: \"/v1/users/{user_id}\"</b>\n    };\n  }\n  rpc UpdateUser(UpdateUserRequest) returns (UpdateUserResponse) {\n    option (google.api.http) = {\n      <b>patch: \"/v1/users/{user_id}\"</b>\n      body: \"update_spec\"\n    };\n  }\n</pre>\n<p>여기서 <code>post: \"/v1/users\"</code>처럼 생긴 부분이 http api로 rpc를 호출할 때 어떤 endpoint를 어떤 method로 호출해야 하는지 알려준다.</p>\n<ul>\n<li><code>CreateUser</code> rpc는 <code>POST /v1/users</code>를 호출하면 된다.</li>\n<li><code>GetUser</code> rpc는 <code>GET /v1/users/123</code>처럼 호출하면 된다.</li>\n<li><code>UpdateUser</code> rpc는 <code>PATCH /v1/users/123</code>처럼 호출하면 된다.</li>\n</ul>\n<p><code>body: \"*\"</code>, <code>body: \"update_spec\"</code> 부분은 <code>XxxRequest</code> message 안에 있는 필드 중 무엇을 실제 요청으로 보내는 json body로 간주할 거냐는 의미다. <code>\"*\"</code>면 모든 필드가 body에 들어가고 <code>\"update_spec\"</code>처럼 있으면 뒤에 나올 <code>XxxRequest</code> message 안에서 <code>update_spec</code>이라는 이름을 가진 필드의 내용만 보내면 된다는 뜻이다.</p>\n<blockquote>\n<p>hostname(e.g. <code>https://api.winterjung.dev</code>)까지 protobuf로 나타내진 않고 주석처럼 다른 방법으로 합의한다.</p>\n</blockquote>\n<h2>주고받는 api 명세</h2>\n<p>message를 통해 실제로 어떤 값을 보내야 하고 어떤 값을 반환해주는지 정의해둔다.</p>\n<pre><code class=\"language-protobuf\">enum UserRole {\n  USER_ROLE_UNKNOWN = 0;\n  USER_ROLE_ADMIN = 1;\n}\n\nmessage CreateUserRequest {\n  string name = 1;\n  google.protobuf.StringValue memo = 2;\n  UserRole role = 3;\n  int64 joined_at_ms = 4;\n}\n\nmessage User {\n  string id = 1;\n  string name = 2;\n  google.protobuf.StringValue memo = 3;\n  UserRole role = 4;\n}\n\nmessage CreateUserResponse {\n  User user = 1;\n}\n\nmessage GetUserRequest {\n  string user_id = 1;\n  bool should_include_id = 2;\n}\n\nmessage GetUserResponse {\n  User user = 1;\n}\n\nmessage UpdateUserRequest {\n  message UserUpdateSpec {\n    string name = 1;\n    google.protobuf.StringValue memo = 2;\n    UserRole role = 3;\n  }\n  string user_id = 1;\n  UserUpdateSpec update_spec = 2;\n  google.protobuf.FieldMask update_mask = 3;\n}\n\nmessage UpdateUserResponse {}\n</code></pre>\n<p>뭔가 많지만 하나씩 보면 json과 그리 다를 바 없다.</p>\n<h3>읽어보기</h3>\n<h4>각종 타입</h4>\n<pre><code class=\"language-protobuf\">message CreateUserRequest {\n  string name = 1;\n  google.protobuf.StringValue memo = 2;\n  UserRole role = 3;\n  int64 joined_at_ms = 4;\n}\n</code></pre>\n<p>아까 말했던 <code>POST /v1/users</code>의 json body로 들어가는 message다. 오른쪽에 붙어있는 1, 2, 3, 4 같은 숫자는 protobuf의 field number인데 grpc 동작 방식상 중요하나 실제로 json api 명세상 무시해도 되는 부분이다.\njson body를 보낼 땐 아래처럼 생겼다.</p>\n<pre><code class=\"language-json\">{\n    \"name\": \"john\",\n    \"memo\": null,\n    \"role\": \"USER_ROLE_ADMIN\",\n    \"joined_at_ms\": \"1612137600000\"\n}\n</code></pre>\n<ul>\n<li><code>string</code> 타입인 <code>name</code> 필드가 있다.</li>\n<li><code>google.protobuf.StringValue</code> 타입은 optional 필드를 의미한다. <code>google.protobuf.XxxValue</code>처럼 생긴 애들이 여럿 있는데(e.g. <code>BoolValue</code>, <code>Int64Value</code>) 모두 해당 필드는 <code>null</code>이 올 수 있다는 의미다.\n<ul>\n<li><code>string</code>, <code>bool</code>, <code>int32</code>, <code>int64</code> 같은 primitive 타입은 보통 required 필드로 간주한다.</li>\n</ul>\n</li>\n<li><code>UserRole</code>은 enum 타입이다. <code>1</code>을 보내든 <code>\"USER_ROLE_ADMIN\"</code>을 보내든 동일하게 처리한다.</li>\n<li><code>int64</code> 타입은 numeric value라는 것을 알려주지만 <a href=\"https://tqdev.com/2016-javascript-cannot-handle-64-bit-integers\">json은 64bit 정수형 타입을 처리하지 못하기에</a> string으로 주고받는다. (정확한 동작은 http 라이브러리마다 다를 수 있다)</li>\n</ul>\n<p>여기서 나와 있진 않지만, 필드 중 타입 앞에 <code>repeated</code>가 붙은 필드가 있다. (e.g. <code>repeated int32 values = 1;</code>)\n이런 필드는 array 타입이고 <code>{\"values\": []}</code>, <code>{\"values\": [1, 2, 3]}</code>처럼 주고받을 수 있다.</p>\n<h4>message는 object</h4>\n<pre><code class=\"language-protobuf\">message User {\n  string id = 1;\n  string name = 2;\n  google.protobuf.StringValue memo = 3;\n  UserRole role = 4;\n}\n\nmessage CreateUserResponse {\n  User user = 1;\n}\n</code></pre>\n<p><code>CreateUser</code> rpc(<code>POST /v1/users</code>)를 호출한 후 응답으로 <code>CreateUserResponse</code> message가 오는데 위와 같이 해석할 수 있다.</p>\n<pre><code class=\"language-json\">{\n    \"user\": {\n        \"id\": \"1\",\n        \"name\": \"john\",\n        \"memo\": null,\n        \"role\": \"USER_ROLE_ADMIN\"\n    }\n}\n</code></pre>\n<ul>\n<li><code>User</code> 같은 message 타입은 <code>{...}</code> 처럼 object라고 해석할 수 있다.</li>\n<li>기본적으로 message 타입은 모두 <code>null</code>이 올 수 있다. 그래서 위 api의 응답으로 아래처럼 오는 게 가능은 하다.\n<pre><code class=\"language-json\">{\n    \"user\": null\n}\n</code></pre>\n</li>\n</ul>\n<h4>path와 query parameter</h4>\n<pre><code class=\"language-protobuf\">message GetUserRequest {\n  string user_id = 1;\n  bool should_include_id = 2;\n}\n\nmessage GetUserResponse {\n  User user = 1;\n}\n</code></pre>\n<p><code>GetUserRequest</code> message에 있는 <code>user_id</code>는 json body로 들어가는 게 아니라 아까 봤던 <code>get: \"/v1/users/{user_id}\"</code> 여기처럼 path에 들어간다.\npath에 있는 필드 이외의 필드(e.g. <code>should_include_id</code> boolean 필드)는 모두 쿼리 파라미터로 들어간다.\n결국 위 사용자 조회 api는 <code>GET /v1/users/123?should_include_id=true</code>처럼 사용할 수 있다.</p>\n<p>만약 <code>repeated</code> 필드가 있고 이를 쿼리 파라미터로 보내고 싶다면 <code>GET /v1/users?keys=1&#x26;keys=2</code> 처럼 같은 쿼리 파라미터 key를 여러 번 사용하면 된다.</p>\n<h4>body option</h4>\n<pre><code class=\"language-protobuf\">message UpdateUserRequest {\n  message UserUpdateSpec {\n    string name = 1;\n    google.protobuf.StringValue memo = 2;\n    UserRole role = 3;\n  }\n  string user_id = 1;\n  UserUpdateSpec update_spec = 2;\n  google.protobuf.FieldMask update_mask = 3;\n}\n\nmessage UpdateUserResponse {}\n</code></pre>\n<p>뭔가 조금 복잡해 보이지만 결국 클라이언트에선 <code>PATCH /v1/users/{user_id}</code> api에 아래처럼 보내주면 된다.</p>\n<ul>\n<li>이름만 업데이트할 때\n<pre><code class=\"language-json\">{\n    \"name\": \"Bob\"\n}\n</code></pre>\n</li>\n<li>메모를 추가할 때\n<pre><code class=\"language-json\">{\n    \"memo\": \"I'm admin user\"\n}\n</code></pre>\n</li>\n<li>메모를 지울 때\n<pre><code class=\"language-json\">{\n    \"memo\": null\n}\n</code></pre>\n</li>\n</ul>\n<p>위에서 언급했듯 <code>UpdateUser</code> rpc는 <code>body: \"update_spec\"</code> option이 있는데 이 때문에 실제로 클라이언트에서 보내야 할 body는 <code>update_spec</code> 필드에 해당하는 <code>UserUpdateSpec</code> message 내용만 보내주면된다.</p>\n<h2>그 외</h2>\n<p>protobuf는 사용하는 조직마다 그 컨벤션이 다르기에 네이밍 부분이라든지, 상세한 규칙이 다른 부분은 있겠으나 보편적으로 읽는 방법은 비슷하다.\nprotobuf를 기반으로 generate 된 swagger를 <a href=\"https://editor.swagger.io/\">swagger editor</a> 같은 곳에 붙여넣어 보는 방법도 있겠으나 source of truth는 protobuf이므로 idl이니 만큼 protobuf로 소통하는 방법이 가장 오해가 적을 거라 생각한다.</p>","frontmatter":{"title":"IDL 읽는 법 (Protocol Buffers)","image":"images/idl.jpg"},"excerpt":"idl header image 클라이언트와 서버간 api 명세를 protocol buffers(이하 protobuf)로 idlInterface Description Language 삼아 개발할 때, 이 idl을 어떻게 읽어야 하는지 간단하게 알아보자…"}},"pageContext":{"slug":"how-to-read-idl","date":"2021-01-17","lastmod":"2021-01-17"}},"staticQueryHashes":["269600272","3159585216"],"slicesMap":{}}