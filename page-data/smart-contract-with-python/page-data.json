{"componentChunkName":"component---src-templates-post-jsx","path":"/smart-contract-with-python/","result":{"data":{"markdownRemark":{"html":"<h2>어떤 글인가</h2>\n<p>11월 21일 화요일, 블록체인 스터디에서 <a href=\"https://github.com/pipermerriam/web3.py\">web3.py</a>를 이용한 스마트 컨트랙트 배포와 활용에 대해 발표했다. 본래는 PDF파일을 블록체인에 올린 원본 증명 서비스의 간단한 개념 증명을 구현하려 했지만, 초기 계획보다 작업을 많이 하지 못해 2주에 걸쳐 작업하기로 결정했다. 이 글을 통해 <strong>이더리움 노드를 설치해 구동시키고 파이썬을 사용해 스마트 컨트랙트를 컴파일 한 후 배포하기까지의 과정</strong> 과 그러면서 있었던 <strong>여러 문제 상황들을 어떻게 해결했는지</strong> 회고하고자 한다.</p>\n<h2>파이썬을 사용한 이유</h2>\n<p>기존에 있던 예제들을 보면 대부분 web3.js와 Node를 사용한 자료들이 많다. 반면 나는 파이썬이 제일 친숙하고 기존에 자주 사용하는 서버 스택이 <a href=\"flask.pocoo.org\">Flask</a> 였기에 이번 발표에서 파이썬 <a href=\"flask.pocoo.org\">Flask</a> 서버에서 이더리움의 스마트 컨트랙트를 배포하고, 배포된 컨트랙트와 web3.py를 이용해 상호작용하는걸 코드로 구현해 시연했다.</p>\n<p><img src=\"https://winterj.me/images/20171127/study.jpeg\" alt=\"\"></p>\n<h2>보편적인 스마트 컨트랙트 배포 방식</h2>\n<p>저번 스터디에는 <a href=\"http://winterj.me/project/time_second_token.sol\">Time Token</a>이라는 간단한 스마트 컨트랙트를 만들어 이를 <a href=\"https://github.com/ethereum/mist\">Mist 지갑</a> 클라이언트를 사용해 직접 배포하는 방식을 시연했다. 보통 배포 자체는 지갑 클라이언트를 사용하거나 <a href=\"https://github.com/trufflesuite/truffle\">Truffle</a>을 이용해 컴파일과 테스트를 거친 후 연동되어있는 이더리움 노드(e.g. <a href=\"https://github.com/ethereum/go-ethereum\">Geth</a>, <a href=\"https://github.com/paritytech/parity\">Parity</a>)를 통해 직접 배포하곤한다. TestRPC는 보통 개발단계에서 사용되며 현재 <a href=\"https://github.com/trufflesuite/ganache\">Ganache</a>로 이관되었다. (트러플에 가나슈까지 네이밍은 잘한다는 생각이 든다) 뒤에서도 말하겠지만 가나슈를 이용하면 스마트 컨트랙트를 개발하고 배포하는데 있어 여러 이점이 있다.</p>\n<ul>\n<li><a href=\"http://goodjoon.tistory.com/261\">스마트 컨트랙트의 이해</a></li>\n</ul>\n<h2>이번에 해본 배포 방식</h2>\n<p>Geth를 설치하고 구동시켜 프라이빗 체인을 구성시킨 후 solc를 사용해 스마트 컨트랙트 소스를 컴파일 한 후 web3를 사용해 저수준에서 직접 배포해봤다. 이를 위해선 여러모로 설치하고 설정해줘야 할 것들이 몇 가지 있는데 이 과정에서 많은 어려움이 있었다.</p>\n<h2>사전 준비</h2>\n<h3>Geth</h3>\n<h4>설치</h4>\n<p>먼저 이더리움 블록체인과 상호작용할 수 있는 노드가 필요하다. 여기서는 유지보수가 잘 되어있고 참고할 질문들이 많고 커뮤니티에서 논의가 활발한 Geth를 사용했다. macOS 기준으로 <code>brew install geth</code> 를 통해 손쉽게 설치할 수 있다.</p>\n<h4>설정</h4>\n<p>설치가 완료되었으면 이제 세가지 선택지가 존재한다.</p>\n<ol>\n<li>이더리움 메인넷과 연동하기</li>\n<li>이더리움 테스트넷과 연동하기</li>\n<li>프라이빗 네트워크 구성하기</li>\n</ol>\n<p>목적은 개발이기 때문에 당연히 3번으로 가야하고, 그러기 위해선 <strong>첫번째 블록(Genesis Block)</strong> 을 우리가 설정해주고, geth한테 이 설정을 알려줄 필요가 있다. 더불어 <a href=\"https://souptacular.gitbooks.io/ethereum-tutorials-and-tips-by-hudson/content/private-chain.html\">이 글</a>에 따르면 프라이빗 네트워크임을 다음과 같이 알려줄 수 있다고 한다.</p>\n<ol>\n<li>커스텀 제네시스 파일</li>\n<li>커스텀 체인 데이터 폴더</li>\n<li>커스텀 네트워크 ID</li>\n<li>(권장) discovery 옵션 비활성화</li>\n</ol>\n<p>4가지 모두 별도로 설정해줄 것이며, 먼저 <code>CustomGenesis.json</code> 이라는 파일을 하나 만들어준다.</p>\n<pre><code class=\"language-json\">{\n  \"config\": {\n        \"chainId\": 42,\n        \"homesteadBlock\": 0,\n        \"eip155Block\": 0,\n        \"eip158Block\": 0\n    },\n  \"alloc\": {},\n  \"coinbase\"   : \"0x0000000000000000000000000000000000000000\",\n  \"difficulty\" : \"0x20000\",\n  \"extraData\"  : \"\",\n  \"gasLimit\"   : \"0x2fefd8\",\n  \"nonce\"      : \"0x0000000012345678\",\n  \"mixhash\"    : \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n  \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n  \"timestamp\"  : \"0x00\"\n}\n</code></pre>\n<h5>주의점</h5>\n<ol>\n<li><code>nonce</code> 값을 무작위적으로 선택된 값으로 할당한다.</li>\n<li><code>chainId</code> 값을 0 이 아닌 값으로 할당한다.</li>\n<li><code>difficulty</code> 값을 적절히 할당한다. 참고로 <code>0x20000</code> 의 난이도로는 2013 맥북 프로 기준 1초에 1블럭 꼴로 채굴된다.</li>\n</ol>\n<h4>환경 구성</h4>\n<p>그 후 <code>geth init CustomGenesis.json --datadir chain-data</code> 를 통해 초기 프라이빗 네트워크 환경을 구성해준다. 이 때 <code>--datadir</code> 인자로 체인 데이터가 쌓일 폴더를 지정해줄 수 있다.</p>\n<p><img src=\"https://winterj.me/images/20171127/init_success.png\" alt=\"\"></p>\n<p>위와 같이 초기화가 잘 되었다면 실질적으로 geth를 구동시켜줘야 한다.</p>\n<h4>실행</h4>\n<pre><code class=\"language-sh\">geth --rpc --rpccorsdomain \"*\" --nodiscover --datadir \"chain-data\" --port \"30303\" --rpcapi \"db,eth,net,web3,personal,admin,miner,debug,txpool\" --networkid 1001012\n</code></pre>\n<p>위 명령어로 노드를 구동시켜줬다. 중요한점은 <code>--nodiscover</code> 옵션과 <code>--networkid</code> 옵션에 무작위 수를 주는 것이다. 그래야 프라이빗 네트워크로 구동된다. 별도의 ipcapi 옵션은 주지 않았지만 큰 문제 없었고 향후 web3.py에서 <code>HTTPProvider</code>를 사용하려면 필히 rpcapi 옵션을 설정해줘야 한다.</p>\n<p><img src=\"https://winterj.me/images/20171127/geth_start.png\" alt=\"\"></p>\n<p>중간에 있는 경고 메시지를 제외하면 이와 비슷한 결과를 얻을 수 있다. 아래를 보면 별도의 IPC 옵션을 주지 않아도 IPC endpoint와 같이 HTTP endpoint를 얻었음을 확인할 수 있다.</p>\n<h4>지갑 생성</h4>\n<p>마지막으로 새로운 쉘을 열어서</p>\n<ul>\n<li><code>geth attach http://127.0.0.1:8545</code> 혹은</li>\n<li><code>geth attach ./chain-data/geth.ipc</code></li>\n</ul>\n<p>명령어를 통해 콘솔에 접속한 뒤 <code>personal.newAccount()</code> 로 새로운 지갑 주소를 만들어준다. 비밀번호를 설정해 최종적으로 생성이 끝나면 <code>eth.accounts</code> 명령어로 다시 확인해볼 수 있다.</p>\n<h4>Error: insufficient funds for gas * price + value</h4>\n<p>geth, solc, web3.py를 전부 설치하고 개발을 하다가 컨트랙트를 배포하는 시점에서 <code>insufficient funds for gas * price + value</code> 에러를 만났다. 처음에는 단순히 account에 돈이 없거나 gas를 잘못설정해준줄 알고 이것저것 바꾸고 모든 지갑에 100 ETH 씩 채워두고 트랜잭션을 쓸 때도 <code>gasLimit - 1</code> 만큼 gas를 주거나 했다. 그래도 안되길래 계속 찾아보니 <code>genesis.json</code>에 있던 <code>chainId</code>를 0으로 설정해준게 원인이었다. 그래서 0을 대충 42정도로 바꿔주니 그 후 트랜잭션은 매우 잘 발행되었다.</p>\n<ul>\n<li><a href=\"https://ethereum.stackexchange.com/questions/28061/geth-sendtransaction-error-insufficient-funds-for-gas-price-value\">이더리움 개발자 포럼 질문</a></li>\n<li><a href=\"https://github.com/ethereum/go-ethereum/issues/15461\">Geth 이슈</a></li>\n</ul>\n<h3>Solc</h3>\n<p>solc는 solidity 언어를 EVM(Ethereum Virtual Machine)에서 사용할 수 있게끔 바이트코드로 변환시켜주는 컴파일러다. 흔히 <a href=\"https://github.com/ethereum/solidity/releases\">solidity가 버전업 됐다는 것</a>은 이 solc라는 컴파일러가 버전업 됐다는 의미이다. solidity 언어로 작성된 스마트 컨트랙트 코드를 파이썬에서 활용하기 위해선 파이썬 환경에서 동작하는 solc 컴파일러가 필요했고, <a href=\"https://github.com/pipermerriam/py-solc\">py-solc</a>를 사용했다.</p>\n<h4>설치</h4>\n<ol>\n<li><code>brew install solidity</code>로 의존성 설치</li>\n<li><code>pip install py-solc</code>로 파이썬 solc 라이브러리 설치</li>\n</ol>\n<h4>실행</h4>\n<p>이후 파이썬 스크립트 내부에서 <code>from solc import compile_source</code>로 가져와 스마트 컨트랙트 코드를 컴파일할 수 있다. 스마트 컨트랙트 코드는 문자열이며 별도의 <code>.sol</code> 파일을 읽어들이거나 스크립트에 하드코딩 해둘 수 있으며 이번엔 후자로 사용했다.</p>\n<pre><code class=\"language-python\">from solc import compile_source\n\ncontract_source_code = '''\ncontract Greeter {\n    string public greeting;\n\n    function Greeter() {\n        greeting = 'Hello';\n    }\n\n    function setGreeting(string _greeting) public {\n        greeting = _greeting;\n    }\n\n    function greet() constant returns (string) {\n        return greeting;\n    }\n}\n'''\ncompiled_sol = compile_source(contract_source_code)\n</code></pre>\n<p>이 때 <code>compiled_sol</code>의 타입은 <code>dict</code> 형식이다.  매우 길기 때문에 <code>print()</code>보다는 <code>json.dump()</code>로 내용을 보면 <code>\"&#x3C;stdin>:Greeter\"</code>라는 하나의 키 값만 존재하는 것을 확인할 수 있다. 해당 키의 값으로는 또 <code>dict</code>가 존재하는데 이 contract interface의 키로는 <strong>abi</strong>, asm, <strong>bin</strong>, <strong>bin-runtime</strong>, clone-bin, opcodes, devdoc, userdoc가 존재한다. 여기서 abi, bin, bin-runtime이 나중에 web3.py에서 필요한 값들이다.</p>\n<ul>\n<li><a href=\"https://ethereum.stackexchange.com/questions/234/what-is-an-abi-and-why-is-it-needed-to-interact-with-contracts\">ABI란?</a></li>\n</ul>\n<h3>Web3.py</h3>\n<p>geth에서 구동되고 있는 이더리움 프라이빗 네트워크에 스마트 컨트랙트를 배포하고, 배포된 스마트 컨트랙트와 파이썬 서버가 상호작용하기 위해선 <a href=\"https://github.com/ethereum/web3.py\">web3.py</a>가 필요하다. 본래 노드와 HTTP기반 JSON RPC API를 이용해 트랜잭션을 생성하는 등의 작업을 할 수 있고, 이의 wrapper가 web3이다. 그리고 자바스크립트로 구현한 것이 web3.js, 파이썬으로 구현한 것이 web3.py다.</p>\n<ul>\n<li><a href=\"http://goodjoon.tistory.com/255\">JSON RPC API 기본</a></li>\n</ul>\n<h4>설치</h4>\n<p><code>pip install web3</code>로 간단하게 설치할 수 있다.</p>\n<h2>배포</h2>\n<p>이제 사전 준비가 끝났으니 실제로 스마트 컨트랙트를 배포해 볼 차례가 됐다. 스마트 컨트랙트 코드는 컴파일을 거쳐 나온 <code>abi</code> 와 <code>bin</code>(바이트 코드)를 사용해 <code>Contract</code> 객체를 만들어준 뒤 배포에 사용될 지갑 주소가 포함된 트랜잭션을 생성해 <code>deploy()</code>한다. <code>deploy()</code>의 결과로는 트랜잭션 해시를 반환받는다. 마지막으로 블럭의 채굴이 이루어지면 최종적으로 이더리움 블록체인에 스마트 컨트랙트가 올라간다. 과정을 도식화해보면 다음과 같다.</p>\n<pre><code>    solidity code\n          +\n          |\n+---------+-----------+\n|  compile_source()   |\n+---------+-----------+\n          |\n          | abi, byte_code(bin)\n          |\n+---------------------+\n| web3.eth.contract() |\n+---------------------+\n          |\n          | transaction\n          |\n+---------------------+\n|  contract.deploy()  |\n+---------+-----------+\n          |\n          v\n   transaction hash\n          +\n    ... mining ...\n          |\n          v\n    S U C C E S S\n</code></pre>\n<p>여기까지의 과정을 파이썬 코드로 나타내면 다음과 같다.</p>\n<pre><code class=\"language-python\">import time\nfrom web3 import Web3, HTTPProvider\nfrom solc import compile_source\n\n# Solidity source code\ncontract_source_code = '''\ncontract Greeter {\n    string public greeting;\n\n    function Greeter() {\n        greeting = 'Hello';\n    }\n\n    function setGreeting(string _greeting) public {\n        greeting = _greeting;\n    }\n\n    function greet() constant returns (string) {\n        return greeting;\n    }\n}\n'''\n\n\n# web3.py\nrpc_url = \"http://localhost:8545\"\nw3 = Web3(HTTPProvider(rpc_url))\n# 혹은 IPC를 통해 연결할 수 있다.\n# w3 = Web3(IPCProvider(\"./chain-data/geth.ipc\"))\n# 지갑 주소를 unlock 해준다. 순서대로 지갑 주소, 비밀번호, unlock할 시간 (0은 영원히)\nw3.personal.unlockAccount(w3.eth.accounts[0], \"test\", 0)\n\n\ncompiled_sol = compile_source(contract_source_code)\ncontract_interface = compiled_sol[\"&#x3C;stdin>:Greeter\"]\n\n# 배포 준비, 스마트 컨트랙트 껍데기(abi)에 내용물(bin)을 채운다.\ncontract = w3.eth.contract(abi= contract_interface['abi'],\n                           bytecode= contract_interface['bin'],\n                           bytecode_runtime= contract_interface['bin-runtime'])\n\n\n# 비용을 부담할 주소를 from으로 하는 트랜잭션을 포함해 배포한다.\ntx_hash = contract.deploy(transaction={'from': w3.eth.accounts[0]})\n\n# 마이닝을 해줘야 후에 실제로 사용할 수 있다.\nw3.miner.start(2)\ntime.sleep(5)\nw3.miner.stop()\n</code></pre>\n<p>여기서 마이닝 과정은 TestRPC(현재 <a href=\"https://github.com/trufflesuite/ganache\">Ganache</a> )를 사용한다면 생략될 수 있다. 이번에는 따로 개발 툴들을 사용하지 않았기에 수동으로 마이닝해줘야하며  <code>start()</code>의 인자로 들어가는 정수는 스레드 개수인데 1로 지정해주면 GIL 때문인지 실제로 채굴이 진행되지 않아 2로 지정해줬다.</p>\n<h3>Error: Could not transact with/call contract function, is contract deployed correctly and chain synced?</h3>\n<p>배포만 하고 블록을 채굴하지 않았을 때 나타나는 에러다. 분명히 <code>deploy()</code>를 실행해서 <code>tx_hash</code>까지 잘 받아왔는데 나중에 <code>web3.eth.getTransactionReceipt()</code>로 contract 주소를 받아오려 할 때 나타났던 에러로, 에러메시지의 말대로 제대로 배포되었고 체인이 동기화 되었는지 확인했더니 트랜잭션은 잘 생성 되었으나 채굴이 이루어져 블록에 포함되지 않아서 나타나는 문제였다.</p>\n<h2>사용</h2>\n<p><code>tx_hash</code> 혹은 <code>contract_address</code>를 통해 스마트 컨트랙트와 상호작용할 수 있다. 어차피 <code>contract_address</code> 또한 <code>tx_hash</code>로부터 얻을 수 있는 값이니 전자의 상황으로 진행했다. 코드는 앞과 이어진다.</p>\n<pre><code class=\"language-python\"># 배포된 컨트랙트 주소를 받아오기 위해 트랜잭션 receipt를 얻어온다.\ntx_receipt = w3.eth.getTransactionReceipt(tx_hash)\ncontract_address = tx_receipt['contractAddress']\n\n# 아까 만들어둔 컨트랙트 객체에 주소를 알려줌으로써 실제로 작동할 수 있게끔 한다.\ncontract_instance = contract(contract_address)\n\n# 컨트랙트의 greet() 함수를 호출한다.\nprint('Contract value: {}'.format(contract_instance.call().greet()))\n\n# get이 아닌 set 동작을 위해선 트랜잭션을 발행해 아까와 마찬가지로 채굴을 해줘야 한다.\n# 여기서 setGreeting()은 컨트랙트에 있던 함수다.\ncontract_instance.transact({\"from\": w3.eth.accounts[0]}).setGreeting(\"WinterJ\")\nprint('Setting value to: WinterJ')\n\n\nw3.miner.start(2)\ntime.sleep(5)\nw3.miner.stop()\n\n# 그리고 다시 값을 확인해보면 WinterJ가 나옴을 확인할 수 있다.\nprint('Contract value: {}'.format(contract_instance.call().greet()))\n</code></pre>\n<h2>결과</h2>\n<p>별도의 <code>.py</code> 파일로 만들어 실행시켜 보면 아래와 같이 잘 동작함을 확인할 수 있다.</p>\n<blockquote>\n<p>로그는 디버깅을 위해 첨부했다. 크게 신경쓰지 않고 마지막 Contract value 값이 바뀌었음만 확인하자.</p>\n</blockquote>\n<p><img src=\"https://winterj.me/images/20171127/finish.png\" alt=\"\"></p>\n<p>위의 코드와 <code>json</code> 파일은 <a href=\"https://github.com/JungWinter/file-on-blockchain\">Github</a>에 올라가 있다. 혹시 잘못된 점이나 궁금한 점이 있다면 언제든지 <strong><a href=\"mailto:wintermy201@gmail.com\">wintermy201@gmail.com</a></strong> 로 메일을 보내주기 바랍니다.</p>\n<h2>이제 해야할 것</h2>\n<ul>\n<li>제대로된 컨트랙트 코딩</li>\n<li>Flask 서버 제작</li>\n<li>간단한 프론트 페이지 제작</li>\n<li>최소한으로 동작하는 모델 만들기</li>\n</ul>","frontmatter":{"title":"파이썬으로 스마트 컨트랙트 개발하기","image":null},"excerpt":"어떤 글인가 11월 21일 화요일, 블록체인 스터디에서 web3.py를 이용한 스마트 컨트랙트 배포와 활용에 대해 발표했다. 본래는 PDF파일을 블록체인에 올린 원본 증명 서비스의 간단한 개념 증명을 구현하려 했지만, 초기 계획보다 작업을 많이 하지…"}},"pageContext":{"slug":"smart-contract-with-python","date":"2017-11-27","lastmod":"2017-11-27"}},"staticQueryHashes":["269600272","3159585216"],"slicesMap":{}}