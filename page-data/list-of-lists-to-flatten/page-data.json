{"componentChunkName":"component---src-templates-post-jsx","path":"/list-of-lists-to-flatten/","result":{"data":{"markdownRemark":{"html":"<p>우연히 커뮤니티의 프로그래밍 게시판에서 파이썬의 2중 리스트 를 일자화 시키는 것에 대해 보게되었다.<br>\n2중 리스트를 1차원 리스트로 만드는 방법은 몇 개 알고 있었는데 어떤 댓글에서 <code>sum(numbers, [])</code>라는 식으로 2중 리스트를 일자화 시키는 것을 보고 전혀 알지 못했던 트릭이라 신기했다.<br>\n동작 원리를 설명할 겸 다른 flatten 방식도 살펴보자.</p>\n<h2>여러 방법들</h2>\n<p><code>list_of_lists = [[1, 2], [3, 4]]</code> 라는 (2, 2) 형상의 list가 있다고 가정하면<br>\n이 list를 <code>[1, 2, 3, 4]</code>의 1차원 리스트로 만드는 방법은 여러가지가 있다.</p>\n<h3>itertools.chain()</h3>\n<p>파이썬의 표준 라이브러리 중 <code>itertools</code>에는 iterable한 컨테이너랑 쓸 수 있는 여러 유용한 함수가 존재한다.<br>\n이 중 <a href=\"https://docs.python.org/3/library/itertools.html#itertools.chain\">itertools.chain()</a>이라는 함수는 인자로 받은 <code>iterator</code>들의 원소를 연결해 반환하는 함수이다.</p>\n<pre><code class=\"language-python\">def chain(*iterables):\n    # chain('ABC', 'DEF') --> ['A', 'B', 'C', 'D', 'E', 'F']\n    for it in iterables:\n        for element in it:\n            yield element\n</code></pre>\n<p>하지만 여기에 바로 <code>list_of_lists</code>를 전달한다고 우리가 원하는 1차원 리스트를 얻을 수 없다.<br>\n<code>chain()</code>함수는 인자들을 엮어주는 것이므로 하나의 list만 달랑 던져주면 던져준 그대로 2차원 리스트를 반환하며 원하는 대로 작동하진 않는다.</p>\n<pre><code class=\"language-python\">>>> list_of_lists = [[1, 2], [3, 4]]\n>>> list(itertools.chain(list_of_lists))\n[[1, 2], [3, 4]]\n</code></pre>\n<p>이 때 원하는 결과값인 <code>[1, 2, 3, 4]</code>를 얻기 위해선 앞에 <code>*(asterisk)</code>을 붙여주어 전달해야한다.<br>\n그러면 iterable한 컨테이너 테이터를 언패킹하여 전달한다.</p>\n<pre><code class=\"language-python\">>>> list_of_lists = [[1, 2], [3, 4]]\n>>> list(itertools.chain(*list_of_lists))\n[1, 2, 3, 4]\n</code></pre>\n<p>추가로 <code>*(asterisk)</code>의 다양한 쓰임새는 <a href=\"https://mingrammer.com/\">mingrammer</a>님의 <a href=\"https://mingrammer.com/understanding-the-asterisk-of-python\">파이썬의 Asterisk(*) 이해하기</a>글에서 확인할 수 있다.</p>\n<h4>itertools.chain.from_iterable()</h4>\n<p>위의 귀찮음을 피하고자 <a href=\"https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable\">from_iterable 메서드</a>가 존재한다.</p>\n<pre><code class=\"language-python\">def from_iterable(iterables):\n    # chain.from_iterable(['ABC', 'DEF']) --> ['A', 'B', 'C', 'D', 'E', 'F']\n    for it in iterables:\n        for element in it:\n            yield element\n</code></pre>\n<p>앞의 예제 처럼 하나의 <code>iterator</code>만 전달해도 <code>iterator</code>의 element들을 조회하면서 lazy하게 넘겨주는 것을 확인할 수 있다.</p>\n<pre><code class=\"language-python\">>>> list_of_lists = [[1, 2], [3, 4]]\n>>> list(itertools.chain.from_iterable(list_of_lists))\n[1, 2, 3, 4]\n</code></pre>\n<h3>리스트 컴프리헨션 (list comprehension)</h3>\n<p>어찌보면 phtonic하다고 볼 수도 있는데 개인적으로는 코드가 그리 직관적으로 다가오진 않는다.</p>\n<pre><code class=\"language-python\">>>> list_of_lists = [[1, 2], [3, 4]]\n>>> [y for x in list_of_lists for y in x]\n[1, 2, 3, 4]\n</code></pre>\n<p>원래 컴프리헨션은 가독성을 높이는 기법이라고 생각하는데 이런 2차원 리스트를 1차원 리스트로 만들 때는 별로 가독성이 높아지지 않는 것 같다.</p>\n<ul>\n<li><code>[y for x in list_of_lists for y in x]</code> 이렇게 구문이 주어지면</li>\n<li><code>for x in list_of_lists</code> 구문이 먼저 해석되어 <code>list_of_lists</code>의 element들이 각각 x에 들어가게되고</li>\n<li><code>[y for y in x]</code> 구문이 해석되어 각각의 x에 들어있는 element들이 y로 조회되고 최종적으로 y로 이루어진 1차원 리스트가 생성된다.</li>\n</ul>\n<p>그나마 좀 더 알아보기 쉽게 하자면 <code>[second for first in list_of_lists for second in first]</code>정도인데 그게 그거 같다.</p>\n<h3>sum()</h3>\n<p>이런 방법이 있는줄 처음 알게된 기법이다.</p>\n<pre><code class=\"language-python\">>>> list_of_lists = [[1, 2], [3, 4]]\n>>> sum(list_of_lists, [])\n[1, 2, 3, 4]\n</code></pre>\n<p>본래 sum함수는 <a href=\"https://docs.python.org/3/library/functions.html#sum\">built-in functions 문서</a>를 참고하면 <code>sum(iterable[, start])</code>의 형태를 띄고있고, <code>start</code>와 <code>iterable</code>의 <code>items</code>를 더해 반환하는 함수이다.<br>\n보통 <code>sum([1, 2, 3, 4])</code>같은 형태로 sum을 사용할 때 <code>iterable</code>이 <code>[1, 2, 3, 4]</code>이고 디폴트로 지정된 <code>start</code>의 값은 <code>0</code>인 셈이다.</p>\n<p><code>sum([[1, 2], [3, 4]])</code>같은 식으로 사용하면 2차원 리스트의 원소들인 <code>[1, 2]</code>와 <code>[3, 4]</code>가 더해져 <code>[1, 2, 3, 4]</code>가 되는게 아니냐 할 수 있는데 <code>start</code>의 값이 디폴트로 0이기 때문에 저런식으로 그냥 전달해 버리면 <code>TypeError: unsupported operand type(s) for +: 'int' and 'list'</code>처럼 int에 list를 더할 수 없다는 <code>TypeError</code>가 발생한다.</p>\n<blockquote>\n<p><code>start</code>가 맨 왼쪽에서 더해지는 대상이기 때문에 list에 int를 더할 때 발생하는 <code>TypeError: can only concatenate list (not \"int\") to list</code>에러 메시지가 아닌 것이다.</p>\n</blockquote>\n<p>그래서 <code>sum([[1, 2], [3, 4]], [])</code>의 형태로 사용해야 <code>[] + [1, 2] + [3, 4]</code>로 해석되어 우리가 원하는 1차원 리스트를 구할 수 있는 것이다.</p>\n<h3>그 외</h3>\n<pre><code class=\"language-python\">>>> list_of_lists = [[1, 2], [3, 4]]\n>>> result = []\n>>> for item in list_of_lists:\n        result.extend(item)\n>>> result\n[1, 2, 3, 4]\n</code></pre>\n<p>같은 식으로 for문으로 돌려서 <code>extend</code> 시키거나 <code>+</code> 시킬 수도 있겠지만 이는 논외로 치겠다.<br>\n저 두 줄로 나뉘어진 구문도 리스트 컴프리헨션으로 한줄로 줄일 수 있겠으나 <code>[b.extend(x) for x in a]</code>의 형태는 <code>[None, None]</code>을 반환하고 외부 변수인 b를 변형시키기 때문에 적절하지 않다고 생각한다.</p>\n<h2>성능 비교</h2>\n<p>간단하게 4가지의 방법을 비교해 보겠다.</p>\n<ul>\n<li><code>itertools.chain()</code></li>\n<li><code>itertools.chain.from_iterable()</code></li>\n<li>리스트 컴프리헨션</li>\n<li><code>sum()</code></li>\n</ul>\n<pre><code class=\"language-python\">from itertools import chain\nlist_of_lists = [[x, 0] for x in range(10000)]\n\n%timeit list(chain(*list_of_lists))\n# 1000 loops, best of 3: 491 µs per loop\n\n%timeit list(chain.from_iterable(list_of_lists))\n# 1000 loops, best of 3: 429 µs per loop\n    \n%timeit [y for x in list_of_lists for y in x]\n# 1000 loops, best of 3: 725 µs per loop\n    \n%timeit sum(list_of_lists, [])\n# 1 loop, best of 3: 211 ms per loop\n</code></pre>\n<p>결과를 보면 <code>sum()</code>함수만 끔찍하게 느리고 나머지 셋은 고만고만함을 알 수 있다.<br>\n성능과 가독성 중 무엇을 중시하냐의 차이지만 개인적으로 <code>itertools.chain()</code> 자체도 가독성이 나쁘다고 볼 수 없기에 <code>sum()</code>보다는 <code>chain()</code>을 쓰지 않을까 싶다.</p>\n<h2>덧. Numpy</h2>\n<p>외부 라이브러리를 제외하고 표준 라이브러리만 생각하다 보니 <code>Numpy</code>를 깜빡했다.<br>\n<code>list_of_list</code>를 ndarray객체로 바꾸어 <code>reshape()</code>메서드와 <code>flatten()</code>메서드를 실행한 결과를 확인해보자.</p>\n<pre><code class=\"language-python\">import numpy as np\nlist_of_lists = [[x, 0] for x in range(10000)]\nn_lol = np.array(list_of_lists)\n\n%timeit n_lol.reshape(-1)\n# 1000000 loops, best of 3: 768 ns per loop\n\n%timeit n_lol.flatten()\n# 1000000 loops, best of 3: 1 µs per loop\n</code></pre>\n<p><code>itertools.chain()</code>보다 수백배 빠르다는 것을 알 수 있다.</p>\n<h2>결과 비교 그래프</h2>\n<p>성능들을 한눈에 알아보기 쉽게 하기 위해 <code>matplotlib</code>를 통해 그래프로 시각화 시켜주었다.<br>\n<a href=\"https://github.com/JungWinter/Code_Study/blob/master/Etc/list%20of%20lists%20to%20flatten.ipynb\">그래프를 생성하는 Jupyter 코드</a></p>\n<p><img src=\"https://winterj.me/images/20170421/result.png\" alt=\"결과\">\nlog스케일의 그래프임으로 x축에서 1칸의 차이는 실질적으로 10배의 차이다.<br>\n<code>Numpy</code>와 <code>itertools</code>의 차이는 약 100배, <code>Numpy</code>와 <code>sum()</code>의 차이는 <strong>1000배 이상</strong>이다.</p>","frontmatter":{"title":"파이썬에서 2중 리스트를 flatten하게 만들기","image":null},"excerpt":"우연히 커뮤니티의 프로그래밍 게시판에서 파이썬의 2중 리스트 를 일자화 시키는 것에 대해 보게되었다. 2중 리스트를 1차원 리스트로 만드는 방법은 몇 개 알고 있었는데 어떤 댓글에서 sum(numbers, [])라는 식으로 2중 리스트를 일자화 시키…"}},"pageContext":{"slug":"list-of-lists-to-flatten","date":"2017-04-21","lastmod":"2017-04-21"}},"staticQueryHashes":["269600272","3159585216"],"slicesMap":{}}