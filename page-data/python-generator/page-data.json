{"componentChunkName":"component---src-templates-post-jsx","path":"/python-generator/","result":{"data":{"markdownRemark":{"html":"<p><a href=\"https://docs.python.org/3/tutorial/classes.html#generators\">Generator(제네레이터)</a>는 제네레이터 함수가 호출될 때 반환되는 <a href=\"https://docs.python.org/3/tutorial/classes.html#iterators\">iterator(이터레이터)</a>의 일종이다. 제네레이터 함수는 일반적인 함수와 비슷하게 생겼지만 <code>yield 구문</code>을 사용해 데이터를 원하는 시점에 반환하고 처리를 다시 시작할 수 있다. 일반적인 함수는 진입점이 하나라면 제네레이터는 진입점이 여러개라고 생각할 수 있다. 이러한 특성때문에 제네레이터를 사용하면 원하는 시점에 원하는 데이터를 받을 수 있게된다.</p>\n<h3>예제</h3>\n<pre><code class=\"language-python\">>>> def generator():\n...     yield 1\n...     yield 'string'\n...     yield True\n\n>>> gen = generator()\n>>> gen\n&#x3C;generator object generator at 0x10a47c678>\n>>> next(gen)\n1\n>>> next(gen)\n'string'\n>>> next(gen)\nTrue\n>>> next(gen)\nTraceback (most recent call last):\n  File \"&#x3C;stdin>\", line 1, in &#x3C;module>\nStopIteration\n</code></pre>\n<h3>동작</h3>\n<ol>\n<li>yield문이 포함된 제네레이터 함수를 실행하면 제네레이터 객체가 반환되는데 이 때는 함수의 내용이 실행되지 않는다.</li>\n<li><code>next()</code>라는 빌트인 메서드를 통해 제네레이터를 실행시킬 수 있으며 <code>next()</code> 메서드 내부적으로 iterator를 인자로 받아 이터레이터의 <code>__next__()</code> 메서드를 실행시킨다.</li>\n<li>처음 <code>__next__()</code> 메서드를 호출하면 함수의 내용을 실행하다 yield문을 만났을 때 처리를 중단한다.</li>\n<li>이 때 모든 local state는 유지되는데 변수의 상태, 명령어 포인터, 내부 스택, 예외 처리 상태를 포함한다.</li>\n<li>그 후 제어권을 상위 컨텍스트로 양보(yield)하고 또 <code>__next__()</code>가 호출되면 제네레이터는 중단된 시점부터 다시 시작한다.</li>\n</ol>\n<blockquote>\n<p>yield문의 값은 어떤 메서드를 통해 제네레이터가 다시 동작했는지에 따라 다른데, <code>__next__()</code>를 사용하면 None이고 <code>send()</code>를 사용하면 메서드로 전달 된 값을 갖게되어 외부에서 데이터를 입력받을 수 있게 된다.</p>\n</blockquote>\n<h3>이점</h3>\n<p>List, Set, Dict 표현식은 iterable(이터러블)하기에 for 표현식 등에서 유용하게 쓰일 수 있다. 이터러블 객체는 유용한 한편 모든 값을 메모리에 담고 있어야 하기 때문에 큰 값을 다룰 때는 별로 좋지 않다. 제네레이터를 사용하면 yield를 통해 그때그때 필요한 값만을 받아 쓰기때문에 모든 값을 메모리에 들고 있을 필요가 없게된다.</p>\n<blockquote>\n<p><code>range()</code>함수는 Python 2.x에서 리스트를 반환하고 Python 3.x에선 range객체를 반환한다. 이 range객체는 제네레이터, 이터레이터가 아니다. 실제로 <code>next(range(1))</code>를 호출해보면 TypeError: 'range' object is not an iterator 오류가 발생한다. 그렇지만 내부 구현상 제네레이터를 사용한 것 처럼 메모리 사용에 있어 이점이 있다.</p>\n</blockquote>\n<pre><code class=\"language-python\">>>> import sys\n>>> a = [i for i in range(100000)]\n>>> sys.getsizeof(a)\n824464\n>>> b = (i for i in range(100000))\n>>> sys.getsizeof(b)\n88\n</code></pre>\n<p>다만 제네레이터는 그때그때 필요한 값을 던져주고 기억하지는 않기 때문에 <code>a 리스트</code>가 여러번 사용될 수 있는 반면 <code>b 제네레이터</code>는 한번 사용된 후 소진된다. 이는 모든 이터레이터가 마찬가지인데 List, Set은 이터러블하지만 이터레이터는 아니기에 소진되지 않는다.</p>\n<pre><code class=\"language-python\">>>> len(list(b))\n100000\n>>> len(list(b))\n0\n</code></pre>\n<p>또한 <code>while True</code> 구문으로 제공받을 데이터가 무한하거나, 모든 값을 한번에 계산하기엔 시간이 많이 소요되어 그때 그때 필요한 만큼만 받아 계산하고 싶을 때 제네레이터를 활용할 수 있다.</p>\n<h3>Generator, Iterator, Iterable간 관계</h3>\n<p><img src=\"http://nvie.com/img/relationships.png\" alt=\"\"></p>\n<h4>Reference</h4>\n<ul>\n<li><a href=\"https://docs.python.org/3/reference/expressions.html#generator.__next__\">제네레이터 <code>__next__()</code> 메서드</a></li>\n<li><a href=\"https://docs.python.org/3/reference/expressions.html#generator.send\">제네레이터 <code>send()</code> 메서드</a></li>\n<li><a href=\"https://docs.python.org/3/reference/expressions.html#yield-expressions\">yield 표현식</a></li>\n<li><a href=\"https://tech.ssut.me/2017/03/24/what-does-the-yield-keyword-do-in-python/\">yield 키워드 알아보기</a></li>\n<li><a href=\"https://item4.github.io/2016-05-09/Generator-and-Yield-Keyword-in-Python/\">Generator와 yield 키워드</a></li>\n<li><a href=\"http://pythonstudy.xyz/python/article/23-Iterator%EC%99%80-Generator\">Iterator와 Generator</a></li>\n</ul>","frontmatter":{"title":"Python의 Generator 알아보기","image":null},"excerpt":"Generator(제네레이터)는 제네레이터 함수가 호출될 때 반환되는 iterator(이터레이터)의 일종이다. 제네레이터 함수는 일반적인 함수와 비슷하게 생겼지만 yield 구문을 사용해 데이터를 원하는 시점에 반환하고 처리를 다시 시작할 수 있다.…"}},"pageContext":{"slug":"python-generator","date":"2018-02-13","lastmod":"2018-02-13"}},"staticQueryHashes":["269600272","3159585216"],"slicesMap":{}}